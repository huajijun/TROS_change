cscope 15 /work_base/TROS_change -q 0000000463 0000051088
	@common.c

1 
	~"comm⁄.h
"

2 
Ba£Ty≥_t
 
	gxSèπC⁄ãxt
[31] = {0};

3 
	$mem˝y
(* 
des
 , * 
§c
, 
numbî
)

5 *
tmp
 = 
des
;

6 * 
tmp2
 = 
§c
;

7 
i
 = 0; i< 
numbî
; i++)

9 *
tmp
++ = *
tmp2
++;

11 
	}
}

	@common.h

1 #i‚de‡
zzy


2 
	#zzy


	)

3 
	#öt8_t
 

	)

4 
	#p‹tCRITICAL_NESTING_IN_TCB
 1

	)

5 
	#queueQUEUE_TYPE_BASE
 ( ( 
uöt8_t
 ) 0U )

	)

6 
	#c⁄figUSE_QUEUE_SETS
 0

	)

8 
	#queueQUEUE_TYPE_BASE
 ( ( 
uöt8_t
 ) 0U )

	)

10 
	#bktQUEUE_LENGTH
 ( 5 )

	)

11 
	#size_t
 

	)

12 
	#uöt8_t
 

	)

13 
	#NULL
 0

	)

14 
	#p‹tPOINTER_SIZE_TYPE
 

	)

15 
	#uöt16_t
 

	)

16 
	#boﬁ
 

	)

17 
	#Ál£
 ()0

	)

18 
	#åue
 ()1

	)

19 
	#c⁄figQUEUE_REGISTRY_SIZE
 8

	)

20 
	#uöt32_t
 

	)

21 
	#uöt64_t
 

	)

22 
	tUBa£Ty≥_t
;

23 
	tBa£Ty≥_t
;

24 * 
	tQueueH™dÀ_t
;

25 
uöt32_t
 
	tTickTy≥_t
;

26 
	#c⁄figTIMER_QUEUE_LENGTH
 2

	)

27 
	#p‹tMAX_DELAY
 ( 
TickTy≥_t
 ) 0xffffffffUL

	)

28 
	#pdFALSE
 
Ál£


	)

29 
	#pdTRUE
 
åue


	)

30 
	#pdPASS
 ( 
pdTRUE
 )

	)

31 
	#queueSEND_TO_BACK
 ( ( 
Ba£Ty≥_t
 ) 0 )

	)

32 
	#queueSEND_TO_FRONT
 ( ( 
Ba£Ty≥_t
 ) 1 )

	)

33 
	#queueOVERWRITE
 ( ( 
Ba£Ty≥_t
 ) 2 )

	)

35 
	#c⁄figMAX_PRIORITIES
 ( 30 )

	)

36 
	#p‹tYIELD_WITHIN_API
 
p‹tYIELD


	)

37 
	#p‹tYIELD
(Ë
	`vP‹tYõld
()

	)

38 
	#SèckTy≥_t
 
uöt32_t


	)

39 
	#c⁄figMAX_TASK_NAME_LEN
 ( 16 )

	)

40 
	#îrQUEUE_EMPTY
 ( ( 
Ba£Ty≥_t
 ) 0 )

	)

41 
	#îrQUEUE_FULL
 ( ( 
Ba£Ty≥_t
 ) 0 )

	)

42 (*
	tTaskFun˘i⁄_t
)( * );

43 
	#îrCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
 ( -1 )

	)

44 
	#îrQUEUE_BLOCKED
 ( -4 )

	)

45 
	#îrQUEUE_YIELD
 ( -5 )

	)

46 
	#p‹tSTACK_TYPE
 
uöt64_t


	)

47 
	#pdFAIL
 ( 
pdFALSE
 )

	)

48 
	#c⁄figMINIMAL_STACK_SIZE
 ( ( Ë1024 )

	)

49 
	#c⁄figTIMER_TASK_STACK_DEPTH
 ( 
c⁄figMINIMAL_STACK_SIZE
 )

	)

50 
	#c⁄figTIMER_TASK_PRIORITY
 ( 2 )

	)

52 
	#p‹tPRIVILEGE_BIT
 ( ( 
UBa£Ty≥_t
 ) 0x00 )

	)

53 
	#èskYIELD_IF_USING_PREEMPTION
(Ë
	`p‹tYIELD_WITHIN_API
()

	)

54 
	#pvP‹tMÆlocAlig√d
–
x
, 
puxSèckBuf„r
 ) ( ( (ÖuxSèckBuf„∏Ë=
NULL
 ) ? ( 
	`pvP‹tMÆloc
––x ) ) ) : (ÖuxSèckBuf„∏Ë)

	)

56 
	#p‹tSTACK_GROWTH
 ( -1 )

	)

57 
	#p‹tDISABLE_INTERRUPTS
(Ë
__asm
 vﬁ©ûê–"c§¯m°©us,1" )

	)

58 
	#p‹tENABLE_INTERRUPTS
(Ë
__asm
 vﬁ©ûê–"c§†m°©us,1" )

	)

60 
	#p‹tPRIVILEGE_BIT
 ( ( 
UBa£Ty≥_t
 ) 0x00 )

	)

61 
	#tskIDLE_PRIORITY
 ( ( 
UBa£Ty≥_t
 ) 0U )

	)

62 
	#p‹tTASK_FUNCTION
–
vFun˘i⁄
, 
pvP¨amëîs
 ) 
	`vFun˘i⁄
–*pvP¨amëî†)

	)

63 
	#c⁄figTICK_RATE_HZ
 ( ( 
TickTy≥_t
 ) 1000 )

	)

64 
	#p‹tTICK_PERIOD_MS
 ( ( 
TickTy≥_t
 ) (1000 / 
c⁄figTICK_RATE_HZ
Ë)

	)

66 
	#tskIDLE_STACK_SIZE
 
c⁄figMINIMAL_STACK_SIZE


	)

	@encoding.h

1 #i‚de‡
__riscv_xÀn


2 
	#STORE
 
sd


	)

3 
	#LOAD
 
ld


	)

4 
	#REGBYTES
 8

	)

6 
	#STORE
 
sw


	)

7 
	#LOAD
 
lw


	)

8 
	#REGBYTES
 4

	)

	@heap2.c

1 
	~"hóp2.h
"

2 
	#p‹tBYTE_ALIGNMENT
 8

	)

3 
	#c⁄figTOTAL_HEAP_SIZE
 ( ( 
size_t
 ) ( 100 * 1024 ) )

	)

4 
	#p‹tBYTE_ALIGNMENT_MASK
 ( 0x0007 )

	)

6 
	sA_BLOCK_LINK


8 
A_BLOCK_LINK
 *
	mpxNextFªeBlock
;

9 
size_t
 
	mxBlockSize
;

10 } 
	tBlockLök_t
;

14 
BlockLök_t
 
	gxSèπ
, 
	gxEnd
;

18 
uöt8_t
 
	gucHóp
[ 
c⁄figTOTAL_HEAP_SIZE
 ];

23 
	#c⁄figADJUSTED_HEAP_SIZE
 ( 
c⁄figTOTAL_HEAP_SIZE
 - 
p‹tBYTE_ALIGNMENT
 )

	)

25 
size_t
 
	gxFªeByãsRemaöög
 = 
c⁄figADJUSTED_HEAP_SIZE
;

36 
	#¥vIn£πBlockI¡oFªeLi°
–
pxBlockToIn£π
 ) \

38 
BlockLök_t
 *
pxIãøt‹
; \

39 
size_t
 
xBlockSize
; \

41 
xBlockSize
 = 
pxBlockToIn£π
->xBlockSize; \

45  
pxIãøt‹
 = &
xSèπ
;ÖxIãøt‹->
pxNextFªeBlock
->
xBlockSize
 < xBlockSize;ÖxIterator =ÖxIterator->pxNextFreeBlock ) \

52 
pxBlockToIn£π
->
pxNextFªeBlock
 = 
pxIãøt‹
->pxNextFreeBlock; \

53 
pxIãøt‹
->
pxNextFªeBlock
 = 
pxBlockToIn£π
; \

54 }

	)

57 c⁄° 
uöt16_t
 
	ghópSTRUCT_SIZE
 = ( (  ( 
BlockLök_t
 ) + ( 
p‹tBYTE_ALIGNMENT
 - 1 ) ) & ~
p‹tBYTE_ALIGNMENT_MASK
 );

58 
	$¥vHópInô
( )

60 
BlockLök_t
* 
pxFú°FªeBlock
;

61 
uöt8_t
 *
pucAlig√dHóp
;

62 
pucAlig√dHóp
 = (
uöt8_t
*)(((
p‹tPOINTER_SIZE_TYPE
)&
ucHóp
[
p‹tBYTE_ALIGNMENT
])&(~(’‹tPOINTER_SIZE_TYPE)
p‹tBYTE_ALIGNMENT_MASK
 ) ) );

64 
xSèπ
.
pxNextFªeBlock
 = (*)
pucAlig√dHóp
;

65 
xSèπ
.
xBlockSize
 = 0;

67 
xEnd
.
pxNextFªeBlock
 = 
NULL
;

68 
xEnd
.
xBlockSize
 = 
c⁄figADJUSTED_HEAP_SIZE
;

72 
pxFú°FªeBlock
 = ( * ) 
pucAlig√dHóp
;

73 
pxFú°FªeBlock
->
xBlockSize
 = 
c⁄figADJUSTED_HEAP_SIZE
;

74 
pxFú°FªeBlock
->
pxNextFªeBlock
 = &
xEnd
;

76 
	}
}

79 *
	$pvP‹tMÆloc
–
size_t
 
xW™ãdSize
 )

81 
BlockLök_t
 *
pxBlock
, *
pxPªviousBlock
, *
pxNewBlockLök
;

82 
boﬁ
 
xHópHasBìnInôüli£d
 = 
Ál£
;

83 *
pvRëu∫
 = 
NULL
;

85 if–
xHópHasBìnInôüli£d
 =
Ál£
)

87 
	`¥vHópInô
();

88 
xHópHasBìnInôüli£d
 = 
åue
;

93 if–
xW™ãdSize
 > 0 )

95 
xW™ãdSize
 +
hópSTRUCT_SIZE
;

98 if––
xW™ãdSize
 & 
p‹tBYTE_ALIGNMENT_MASK
 ) != 0 )

101 
xW™ãdSize
 +–
p‹tBYTE_ALIGNMENT
 - ( xW™ãdSizê& 
p‹tBYTE_ALIGNMENT_MASK
 ) );

106 if––
xW™ãdSize
 > 0 ) && ( xW™ãdSizê< 
c⁄figADJUSTED_HEAP_SIZE
 ) )

110 
pxPªviousBlock
 = &
xSèπ
;

111 
pxBlock
 = 
xSèπ
.
pxNextFªeBlock
;

112  ( 
pxBlock
->
xBlockSize
 < 
xW™ãdSize
 ) && (ÖxBlock->
pxNextFªeBlock
 !
NULL
 ) )

114 
pxPªviousBlock
 = 
pxBlock
;

115 
pxBlock
 =ÖxBlock->
pxNextFªeBlock
;

119 if–
pxBlock
 !&
xEnd
 )

123 
pvRëu∫
 = ( * ) ( ( ( 
uöt8_t
 * ) 
pxPªviousBlock
->
pxNextFªeBlock
 ) + 
hópSTRUCT_SIZE
 );

127 
pxPªviousBlock
->
pxNextFªeBlock
 = 
pxBlock
->pxNextFreeBlock;

130 if––
pxBlock
->
xBlockSize
 - 
xW™ãdSize
 ) > 
hópMINIMUM_BLOCK_SIZE
 )

135 
pxNewBlockLök
 = ( * ) ( ( ( 
uöt8_t
 * ) 
pxBlock
 ) + 
xW™ãdSize
 );

139 
pxNewBlockLök
->
xBlockSize
 = 
pxBlock
->xBlockSizê- 
xW™ãdSize
;

140 
pxBlock
->
xBlockSize
 = 
xW™ãdSize
;

143 
	`¥vIn£πBlockI¡oFªeLi°
––
pxNewBlockLök
 ) );

146 
xFªeByãsRemaöög
 -
pxBlock
->
xBlockSize
;

151  
pvRëu∫
;

153 
	}
}

154 
	$vP‹tFªe
–*
pv
 )

156 
uöt8_t
 *
puc
 = ( uöt8_à* ) 
pv
;

157 
BlockLök_t
 *
pxLök
;

158 if–
pv
 !
NULL
 )

162 
puc
 -
hópSTRUCT_SIZE
;

166 
pxLök
 = ( * ) 
puc
;

169 
	`¥vIn£πBlockI¡oFªeLi°
–––
BlockLök_t
 * ) 
pxLök
 ) );

170 
xFªeByãsRemaöög
 +
pxLök
->
xBlockSize
;

173 
	}
}

	@heap2.h

1 
	#size_t
 

	)

2 
	#uöt8_t
 

	)

3 
	#NULL
 0

	)

4 
	#p‹tPOINTER_SIZE_TYPE
 

	)

5 
	#uöt16_t
 

	)

6 
	#boﬁ
 

	)

7 
	#Ál£
 ()0

	)

8 
	#åue
 ()1

	)

9 
	#hópMINIMUM_BLOCK_SIZE
 ( ( 
size_t
 ) ( 
hópSTRUCT_SIZE
 * 2 ) )

	)

10 *
pvP‹tMÆloc
–
size_t
 
xW™ãdSize
 );

11 
vP‹tFªe
–*
pv
 );

	@list2.c

1 
	~"li°2.h
"

2 
	~"comm⁄.h
"

3 
	$vLi°Inôüli£
–
Li°_t
 * c⁄° 
pxLi°
 )

8 
pxLi°
->
pxIndex
 = ( 
Li°Iãm_t
 * ) &–pxLi°->
xLi°End
 );

12 
pxLi°
->
xLi°End
.
xIãmVÆue
 = 
p‹tMAX_DELAY
;

16 
pxLi°
->
xLi°End
.
pxNext
 = ( 
Li°Iãm_t
 * ) &(ÖxList->xListEnd );

17 
pxLi°
->
xLi°End
.
pxPªvious
 = ( 
Li°Iãm_t
 * ) &(ÖxList->xListEnd );

19 
pxLi°
->
uxNumbîOfIãms
 = ( 
UBa£Ty≥_t
 ) 0U;

25 
	}
}

27 
	$vLi°Inôüli£Iãm
–
Li°Iãm_t
 * c⁄° 
pxIãm
 )

30 
pxIãm
->
pvC⁄èöî
 = 
NULL
;

36 
	}
}

39 
	$vLi°In£π
–
Li°_t
 * c⁄° 
pxLi°
, 
Li°Iãm_t
 * c⁄° 
pxNewLi°Iãm
 )

41 
Li°Iãm_t
 *
pxIãøt‹
;

42 c⁄° 
TickTy≥_t
 
xVÆueOfIn£πi⁄
 = 
pxNewLi°Iãm
->
xIãmVÆue
;

58 if–
xVÆueOfIn£πi⁄
 =
p‹tMAX_DELAY
 )

60 
pxIãøt‹
 = 
pxLi°
->
xLi°End
.
pxPªvious
;

87  
pxIãøt‹
 = ( 
Li°Iãm_t
 * ) &–
pxLi°
->
xLi°End
 );ÖxIãøt‹->
pxNext
->
xIãmVÆue
 <
xVÆueOfIn£πi⁄
;ÖxIterator =ÖxIterator->pxNext )

94 
pxNewLi°Iãm
->
pxNext
 = 
pxIãøt‹
->pxNext;

95 
pxNewLi°Iãm
->
pxNext
->
pxPªvious
 =ÖxNewListItem;

96 
pxNewLi°Iãm
->
pxPªvious
 = 
pxIãøt‹
;

97 
pxIãøt‹
->
pxNext
 = 
pxNewLi°Iãm
;

101 
pxNewLi°Iãm
->
pvC⁄èöî
 = ( * ) 
pxLi°
;

103 –
pxLi°
->
uxNumbîOfIãms
 )++;

104 
	}
}

106 
	$vLi°In£πEnd
–
Li°_t
 * c⁄° 
pxLi°
, 
Li°Iãm_t
 * c⁄° 
pxNewLi°Iãm
 )

108 
Li°Iãm_t
 * c⁄° 
pxIndex
 = 
pxLi°
->pxIndex;

119 
pxNewLi°Iãm
->
pxNext
 = 
pxIndex
;

120 
pxNewLi°Iãm
->
pxPªvious
 = 
pxIndex
->pxPrevious;

123 
pxIndex
->
pxPªvious
->
pxNext
 = 
pxNewLi°Iãm
;

124 
pxIndex
->
pxPªvious
 = 
pxNewLi°Iãm
;

127 
pxNewLi°Iãm
->
pvC⁄èöî
 = ( * ) 
pxLi°
;

129 –
pxLi°
->
uxNumbîOfIãms
 )++;

130 
	}
}

132 
UBa£Ty≥_t
 
	$uxLi°Remove
–
Li°Iãm_t
 * c⁄° 
pxIãmToRemove
 )

136 
Li°_t
 * c⁄° 
pxLi°
 = ( Li°_à* ) 
pxIãmToRemove
->
pvC⁄èöî
;

138 
pxIãmToRemove
->
pxNext
->
pxPªvious
 =ÖxItemToRemove->pxPrevious;

139 
pxIãmToRemove
->
pxPªvious
->
pxNext
 =ÖxItemToRemove->pxNext;

143 if–
pxLi°
->
pxIndex
 =
pxIãmToRemove
 )

145 
pxLi°
->
pxIndex
 = 
pxIãmToRemove
->
pxPªvious
;

148 
pxIãmToRemove
->
pvC⁄èöî
 = 
NULL
;

149 –
pxLi°
->
uxNumbîOfIãms
 )--;

151  
pxLi°
->
uxNumbîOfIãms
;

152 
	}
}

	@list2.h

1 
	~"comm⁄.h
"

2 #i‚de‡
LIST


3 
	#LIST


	)

4 
	sxLIST_ITEM


7 
TickTy≥_t
 
	mxIãmVÆue
;

8 
xLIST_ITEM
 * 
	mpxNext
;

9 
xLIST_ITEM
 * 
	mpxPªvious
;

10 * 
	mpvOw√r
;

11 * 
	mpvC⁄èöî
;

14 
xLIST_ITEM
 
	tLi°Iãm_t
;

16 
	sxMINI_LIST_ITEM


19 
TickTy≥_t
 
	mxIãmVÆue
;

20 
xLIST_ITEM
 * 
	mpxNext
;

21 
xLIST_ITEM
 * 
	mpxPªvious
;

23 
xMINI_LIST_ITEM
 
	tMöiLi°Iãm_t
;

28 
	sxLIST


31 
UBa£Ty≥_t
 
	muxNumbîOfIãms
;

32 
Li°Iãm_t
 * 
	mpxIndex
;

33 
MöiLi°Iãm_t
 
	mxLi°End
;

35 } 
	tLi°_t
;

36 
	#li°SET_LIST_ITEM_OWNER
–
pxLi°Iãm
, 
pxOw√r
 ) ( (ÖxLi°Iãm )->
pvOw√r
 = ( * ) (ÖxOw√∏Ë)

	)

37 
	#li°LIST_IS_EMPTY
–
pxLi°
 ) ( ( 
Ba£Ty≥_t
 ) ( (ÖxLi° )->
uxNumbîOfIãms
 =–
UBa£Ty≥_t
 ) 0 ) )

	)

38 
	#li°GET_OWNER_OF_HEAD_ENTRY
–
pxLi°
 ) ( (&––pxLi° )->
xLi°End
 ))->
pxNext
->
pvOw√r
 )

	)

39 
	#li°SET_LIST_ITEM_VALUE
–
pxLi°Iãm
, 
xVÆue
 ) ( (ÖxLi°Iãm )->
xIãmVÆue
 = ( xVÆuêË)

	)

40 
	#li°GET_LIST_ITEM_VALUE
–
pxLi°Iãm
 ) ( (ÖxLi°Iãm )->
xIãmVÆue
 )

	)

41 
	#li°CURRENT_LIST_LENGTH
–
pxLi°
 ) ( (ÖxLi° )->
uxNumbîOfIãms
 )

	)

42 
	#li°GET_ITEM_VALUE_OF_HEAD_ENTRY
–
pxLi°
 ) ( ( (ÖxLi° )->
xLi°End
 ).
pxNext
->
xIãmVÆue
 )

	)

43 
	#li°LIST_ITEM_CONTAINER
–
pxLi°Iãm
 ) ( (ÖxLi°Iãm )->
pvC⁄èöî
 )

	)

44 
	#li°GET_OWNER_OF_NEXT_ENTRY
–
pxTCB
, 
pxLi°
 ) \

46 
Li°_t
 * c⁄° 
pxC⁄°Li°
 = ( 
pxLi°
 ); \

49 –
pxC⁄°Li°
 )->
pxIndex
 = (ÖxC⁄°Li° )->pxIndex->
pxNext
; \

50 if––* ) ( 
pxC⁄°Li°
 )->
pxIndex
 =–* ) &––pxC⁄°Li° )->
xLi°End
 ) ) \

52 –
pxC⁄°Li°
 )->
pxIndex
 = (ÖxC⁄°Li° )->pxIndex->
pxNext
; \

54 –
pxTCB
 ) = ( 
pxC⁄°Li°
 )->
pxIndex
->
pvOw√r
; \

55 }

	)

	@main.c

1 
	~"hóp2.h
"

2 
	~"queue2.h
"

3 
	~"comm⁄.h
"

4 
	~"èsk.h
"

5 
	~"time.h
"

7 
	#maöCHECK_TIMER_PERIOD_MS
 ( 3000UL / 
p‹tTICK_PERIOD_MS
 )

	)

8 
	#maöDONT_BLOCK
 ( 0UL )

	)

9 
Ba£Ty≥_t
 
	gxD©a
 = 0;

10 
Te°Progøm
();

11 
¥vCheckTimîCÆlback
();

12 
	$vSysˇŒInô
()

14 
TimîH™dÀ_t
 
xCheckTimî
 = 
NULL
;

16 
	`xTaskCª©e
–
Te°Progøm
, "Te°Progøm", 4096, 
NULL
, 20, NULL );

18 
xCheckTimî
 = 
	`xTimîCª©e
–"CheckTimî",–
maöCHECK_TIMER_PERIOD_MS
 ),
pdTRUE
,–* ) 0,
¥vCheckTimîCÆlback
);

20 if–
xCheckTimî
 !
NULL
 )

22 
	`xTimîSèπ
–
xCheckTimî
, 
maöDONT_BLOCK
 );

26 
	`vTaskSèπScheduÀr
();

27 
	}
}

29 
	$Te°Progøm
()

32 
Ba£Ty≥_t
 
a
 =1;

33 
QueueH™dÀ_t
 
ã°queuë
;

34 
ã°queuë
 = 
	`xQueueCª©e
–
bktQUEUE_LENGTH
, –
Ba£Ty≥_t
 ) );

35 
	`xQueueSíd
(
ã°queuë
,&
a
,0);

36 if–
	`xQueueRe˚ive
–
ã°queuë
, &
xD©a
, 0 ) !
îrQUEUE_EMPTY
 )

40 
	}
}

41 
	$¥vCheckTimîCÆlback
()

43 
a
=0;

44 
	}
}

	@other.h

1 
	~"èsk.h
"

2 
	#èskCHECK_FOR_STACK_OVERFLOW
() \

4 c⁄° 
uöt32_t
 * c⁄° 
pulSèck
 = ( uöt32_à* ) 
pxCuºítTCB
->
pxSèck
; \

5 c⁄° 
uöt32_t
 
ulCheckVÆue
 = ( uint32_t ) 0xa5a5a5a5; \

7 if––
pulSèck
[ 0 ] !
ulCheckVÆue
 ) || \

	)

8 –
	gpulSèck
[ 1 ] !
ulCheckVÆue
 ) || \

9 –
pulSèck
[ 2 ] !
ulCheckVÆue
 ) || \

10 –
pulSèck
[ 3 ] !
ulCheckVÆue
 ) ) \

12 
vAµliˇti⁄SèckOvîÊowHook
––
TaskH™dÀ_t
 ) 
pxCuºítTCB
,ÖxCuºítTCB->
pcTaskName
 ); \

15 
	$vAµliˇti⁄SèckOvîÊowHook
–
TaskH™dÀ_t
 
pxTask
, *
pcTaskName
 )

23 
	}
}

	@queue2.c

2 
	~"comm⁄.h
"

3 
	~"li°2.h
"

4 
	~"queue2.h
"

5 
	~"èsk.h
"

6 
	~"time.h
"

7 
	#queueYIELD_IF_USING_PREEMPTION
(Ë
	`p‹tYIELD_WITHIN_API
()

	)

8 
	#queueUNLOCKED
 ( ( 
Ba£Ty≥_t
 ) -1 )

	)

9 
	#queueLOCKED_UNMODIFIED
 ( ( 
Ba£Ty≥_t
 ) 0 )

	)

12 
Ba£Ty≥_t
 
xQueueGíîicSídFromISR
–
QueueH™dÀ_t
 
xQueue
, c⁄° * c⁄° 
pvIãmToQueue
, Ba£Ty≥_à* c⁄° 
pxHighîPri‹ôyTaskWokí
, c⁄° Ba£Ty≥_à
xC›yPosôi⁄
 );

14 
vTaskSu•ídAŒ
( );

15 
Ba£Ty≥_t
 
¥vIsQueueFuŒ
–c⁄° 
Queue_t
 *
pxQueue
 );

17 
Ba£Ty≥_t
 
	$¥vIsQueueEm±y
–c⁄° 
Queue_t
 *
pxQueue
 )

19 
Ba£Ty≥_t
 
xRëu∫
;

21 
	`èskENTER_CRITICAL
();

23 if–
pxQueue
->
uxMesßgesWaôög
 =–
UBa£Ty≥_t
 ) 0 )

25 
xRëu∫
 = 
pdTRUE
;

29 
xRëu∫
 = 
pdFALSE
;

32 
	`èskEXIT_CRITICAL
();

34  
xRëu∫
;

35 
	}
}

37 
Ba£Ty≥_t
 
	$xQueueGíîicRe£t
–
QueueH™dÀ_t
 
xQueue
, 
Ba£Ty≥_t
 
xNewQueue
 )

39 
Queue_t
 * c⁄° 
pxQueue
 = ( Queue_à* ) 
xQueue
;

44 
pxQueue
->
pcTaû
 =ÖxQueue->
pcHód
 + (ÖxQueue->
uxLígth
 *ÖxQueue->
uxIãmSize
 );

45 
pxQueue
->
uxMesßgesWaôög
 = ( 
UBa£Ty≥_t
 ) 0U;

46 
pxQueue
->
pcWrôeTo
 =ÖxQueue->
pcHód
;

47 
pxQueue
->
u
.
pcRódFrom
 =ÖxQueue->
pcHód
 + ( (ÖxQueue->
uxLígth
 - ( 
UBa£Ty≥_t
 ) 1U ) *ÖxQueue->
uxIãmSize
 );

48 
pxQueue
->
xRxLock
 = 
queueUNLOCKED
;

49 
pxQueue
->
xTxLock
 = 
queueUNLOCKED
;

51 if–
xNewQueue
 =
Ál£
 )

58 if–
	`li°LIST_IS_EMPTY
–&–
pxQueue
->
xTasksWaôögToSíd
 ) ) =
pdFALSE
 )

60 if–
	`xTaskRemoveFromEvítLi°
–&–
pxQueue
->
xTasksWaôögToSíd
 ) ) =
pdTRUE
 )

62 
	`queueYIELD_IF_USING_PREEMPTION
();

70 
	`vLi°Inôüli£
–&–
pxQueue
->
xTasksWaôögToSíd
 ) );

71 
	`vLi°Inôüli£
–&–
pxQueue
->
xTasksWaôögToRe˚ive
 ) );

78  
pdPASS
;

79 
	}
}

89 
QueueH™dÀ_t
 
	$xQueueGíîicCª©e
–c⁄° 
UBa£Ty≥_t
 
uxQueueLígth
, c⁄° UBa£Ty≥_à
uxIãmSize
, c⁄° 
uöt8_t
 
ucQueueTy≥
 )

91 
Queue_t
 *
pxNewQueue
;

92 
size_t
 
xQueueSizeInByãs
;

93 
QueueH™dÀ_t
 
xRëu∫
 = 
NULL
;

97 –Ë
ucQueueTy≥
;

101 if–
uxIãmSize
 =–
UBa£Ty≥_t
 ) 0 )

104 
xQueueSizeInByãs
 = ( 
size_t
 ) 0;

110 
xQueueSizeInByãs
 = ( 
size_t
 ) ( 
uxQueueLígth
 * 
uxIãmSize
 ) + ( size_t ) 1;

113 
pxNewQueue
 = ( 
Queue_t
 * ) 
	`pvP‹tMÆloc
––Queue_àË+ 
xQueueSizeInByãs
 );

116 if–
pxNewQueue
 !
NULL
 )

118 if–
uxIãmSize
 =–
UBa£Ty≥_t
 ) 0 )

124 
pxNewQueue
->
pcHód
 = ( 
öt8_t
 * )ÖxNewQueue;

130 
pxNewQueue
->
pcHód
 = ( ( 
öt8_t
 * )ÖxNewQueuêË+ –
Queue_t
 );

135 
pxNewQueue
->
uxLígth
 = 
uxQueueLígth
;

136 
pxNewQueue
->
uxIãmSize
 = uxItemSize;

137 –Ë
	`xQueueGíîicRe£t
–
pxNewQueue
, 
åue
);

139 #i‡–
c⁄figUSE_TRACE_FACILITY
 == 1 )

141 
pxNewQueue
->
ucQueueTy≥
 = ucQueueType;

145 #if–
c⁄figUSE_QUEUE_SETS
 == 1 )

147 
pxNewQueue
->
pxQueueSëC⁄èöî
 = 
NULL
;

152 
xRëu∫
 = 
pxNewQueue
;

155  
xRëu∫
;

156 
	}
}

157 
	$vQueueAddToRegi°ry
–
QueueH™dÀ_t
 
xQueue
, c⁄° *
pcQueueName
 )

159 
UBa£Ty≥_t
 
ux
;

163  
ux
 = ( 
UBa£Ty≥_t
 ) 0U; ux < ( UBa£Ty≥_àË
c⁄figQUEUE_REGISTRY_SIZE
; ux++ )

165 if–
xQueueRegi°ry
[ 
ux
 ].
pcQueueName
 =
NULL
 )

168 
xQueueRegi°ry
[ 
ux
 ].
pcQueueName
 =ÖcQueueName;

169 
xQueueRegi°ry
[ 
ux
 ].
xH™dÀ
 = 
xQueue
;

179 
	}
}

181 
Ba£Ty≥_t
 
	$¥vC›yD©aToQueue
–
Queue_t
 * c⁄° 
pxQueue
, c⁄° *
pvIãmToQueue
, c⁄° 
Ba£Ty≥_t
 
xPosôi⁄
 )

183 
Ba£Ty≥_t
 
xRëu∫
 = 
pdFALSE
;

185 if–
pxQueue
->
uxIãmSize
 =–
UBa£Ty≥_t
 ) 0 )

187 #i‡–
c⁄figUSE_MUTEXES
 == 1 )

189 if–
pxQueue
->
uxQueueTy≥
 =
queueQUEUE_IS_MUTEX
 )

192 
xRëu∫
 = 
	`xTaskPri‹ôyDisöhîô
––* ) 
pxQueue
->
pxMuãxHﬁdî
 );

193 
pxQueue
->
pxMuãxHﬁdî
 = 
NULL
;

202 if–
xPosôi⁄
 =
queueSEND_TO_BACK
 )

204 –Ë
	`mem˝y
––* ) 
pxQueue
->
pcWrôeTo
, 
pvIãmToQueue
, ( 
size_t
 )ÖxQueue->
uxIãmSize
 );

205 
pxQueue
->
pcWrôeTo
 +pxQueue->
uxIãmSize
;

206 if–
pxQueue
->
pcWrôeTo
 >pxQueue->
pcTaû
 )

208 
pxQueue
->
pcWrôeTo
 =ÖxQueue->
pcHód
;

217 –Ë
	`mem˝y
––* ) 
pxQueue
->
u
.
pcRódFrom
, 
pvIãmToQueue
, ( 
size_t
 )ÖxQueue->
uxIãmSize
 );

218 
pxQueue
->
u
.
pcRódFrom
 -pxQueue->
uxIãmSize
;

219 if–
pxQueue
->
u
.
pcRódFrom
 <ÖxQueue->
pcHód
 )

221 
pxQueue
->
u
.
pcRódFrom
 = (ÖxQueue->
pcTaû
 -ÖxQueue->
uxIãmSize
 );

228 if–
xPosôi⁄
 =
queueOVERWRITE
 )

230 if–
pxQueue
->
uxMesßgesWaôög
 > ( 
UBa£Ty≥_t
 ) 0 )

236 --–
pxQueue
->
uxMesßgesWaôög
 );

249 ++–
pxQueue
->
uxMesßgesWaôög
 );

251  
xRëu∫
;

252 
	}
}

266 
Ba£Ty≥_t
 
	$xQueueGíîicSíd
–
QueueH™dÀ_t
 
xQueue
, c⁄° * c⁄° 
pvIãmToQueue
, 
TickTy≥_t
 
xTicksToWaô
, c⁄° 
Ba£Ty≥_t
 
xC›yPosôi⁄
 )

268 
Ba£Ty≥_t
 
xE¡ryTimeSë
 = 
Ál£
, 
xYõldRequúed
;

269 
TimeOut_t
 
xTimeOut
;

270 
Queue_t
 * c⁄° 
pxQueue
 = ( Queue_à* ) 
xQueue
;

293 if––
pxQueue
->
uxMesßgesWaôög
 <ÖxQueue->
uxLígth
 ) || ( 
xC›yPosôi⁄
 =
queueOVERWRITE
 ) )

296 
xYõldRequúed
 = 
	`¥vC›yD©aToQueue
–
pxQueue
, 
pvIãmToQueue
, 
xC›yPosôi⁄
 );

298 #i‡–
c⁄figUSE_QUEUE_SETS
 == 1 )

300 if–
pxQueue
->
pxQueueSëC⁄èöî
 !
NULL
 )

302 if–
	`¥vNŸifyQueueSëC⁄èöî
–
pxQueue
, 
xC›yPosôi⁄
 ) =
pdTRUE
 )

307 
	`queueYIELD_IF_USING_PREEMPTION
();

318 if–
	`li°LIST_IS_EMPTY
–&–
pxQueue
->
xTasksWaôögToRe˚ive
 ) ) =
pdFALSE
 )

320 if–
	`xTaskRemoveFromEvítLi°
–&–
pxQueue
->
xTasksWaôögToRe˚ive
 ) ) =
pdTRUE
 )

326 
	`queueYIELD_IF_USING_PREEMPTION
();

333 if–
xYõldRequúed
 !
pdFALSE
 )

339 
	`queueYIELD_IF_USING_PREEMPTION
();

351 if–
	`li°LIST_IS_EMPTY
–&–
pxQueue
->
xTasksWaôögToRe˚ive
 ) ) =
pdFALSE
 )

353 if–
	`xTaskRemoveFromEvítLi°
–&–
pxQueue
->
xTasksWaôögToRe˚ive
 ) ) =
pdTRUE
 )

359 
	`queueYIELD_IF_USING_PREEMPTION
();

366 if–
xYõldRequúed
 !
pdFALSE
 )

372 
	`queueYIELD_IF_USING_PREEMPTION
();

381 
	`èskEXIT_CRITICAL
();

382  
pdPASS
;

386 if–
xTicksToWaô
 =–
TickTy≥_t
 ) 0 )

390 
	`èskEXIT_CRITICAL
();

395  
îrQUEUE_FULL
;

397 if–
xE¡ryTimeSë
 =
pdFALSE
 )

402 
xE¡ryTimeSë
 = 
pdTRUE
;

411 
	`èskEXIT_CRITICAL
();

416 
	`vTaskSu•ídAŒ
();

420 if–
	`xTaskCheckF‹TimeOut
–&
xTimeOut
, &
xTicksToWaô
 ) =
pdFALSE
 )

422 if–
	`¥vIsQueueFuŒ
–
pxQueue
 ) !
pdFALSE
 )

425 
	`vTaskPœ˚OnEvítLi°
–&–
pxQueue
->
xTasksWaôögToSíd
 ), 
xTicksToWaô
 );

439 if–
	`xTaskResumeAŒ
(Ë=
pdFALSE
 )

441 
	`p‹tYIELD_WITHIN_API
();

448 –Ë
	`xTaskResumeAŒ
();

455 –Ë
	`xTaskResumeAŒ
();

460  
îrQUEUE_FULL
;

463 
	}
}

468 
	$¥vC›yD©aFromQueue
–
Queue_t
 * c⁄° 
pxQueue
, * c⁄° 
pvBuf„r
 )

470 if–
pxQueue
->
uxIãmSize
 !–
UBa£Ty≥_t
 ) 0 )

472 
pxQueue
->
u
.
pcRódFrom
 +pxQueue->
uxIãmSize
;

473 if–
pxQueue
->
u
.
pcRódFrom
 >pxQueue->
pcTaû
 )

475 
pxQueue
->
u
.
pcRódFrom
 =ÖxQueue->
pcHód
;

481 –Ë
	`mem˝y
––* ) 
pvBuf„r
, ( * ) 
pxQueue
->
u
.
pcRódFrom
, ( 
size_t
 )ÖxQueue->
uxIãmSize
 );

483 
	}
}

493 
Ba£Ty≥_t
 
	$xQueueGíîicRe˚ive
–
QueueH™dÀ_t
 
xQueue
, * c⁄° 
pvBuf„r
, 
TickTy≥_t
 
xTicksToWaô
, c⁄° 
Ba£Ty≥_t
 
xJu°Pìkög
 )

495 
Ba£Ty≥_t
 
xE¡ryTimeSë
 = 
pdFALSE
;

496 
TimeOut_t
 
xTimeOut
;

497 
öt8_t
 *
pcOrigöÆRódPosôi⁄
;

498 
Queue_t
 * c⁄° 
pxQueue
 = ( Queue_à* ) 
xQueue
;

502 #i‡––
INCLUDE_xTaskGëScheduÀrSèã
 =1 ) || ( 
c⁄figUSE_TIMERS
 == 1 ) )

514 
	`èskENTER_CRITICAL
();

518 if–
pxQueue
->
uxMesßgesWaôög
 > ( 
UBa£Ty≥_t
 ) 0 )

522 
pcOrigöÆRódPosôi⁄
 = 
pxQueue
->
u
.
pcRódFrom
;

524 
	`¥vC›yD©aFromQueue
–
pxQueue
, 
pvBuf„r
 );

526 if–
xJu°Pìkög
 =
pdFALSE
 )

531 --–
pxQueue
->
uxMesßgesWaôög
 );

533 #i‡–
c⁄figUSE_MUTEXES
 == 1 )

535 if–
pxQueue
->
uxQueueTy≥
 =
queueQUEUE_IS_MUTEX
 )

539 
pxQueue
->
pxMuãxHﬁdî
 = ( 
öt8_t
 * ) 
	`pvTaskIn¸emítMuãxHñdCou¡
();

548 if–
	`li°LIST_IS_EMPTY
–&–
pxQueue
->
xTasksWaôögToSíd
 ) ) =
pdFALSE
 )

550 if–
	`xTaskRemoveFromEvítLi°
–&–
pxQueue
->
xTasksWaôögToSíd
 ) ) =
pdTRUE
 )

552 
	`queueYIELD_IF_USING_PREEMPTION
();

570 
pxQueue
->
u
.
pcRódFrom
 = 
pcOrigöÆRódPosôi⁄
;

574 if–
	`li°LIST_IS_EMPTY
–&–
pxQueue
->
xTasksWaôögToRe˚ive
 ) ) =
pdFALSE
 )

576 if–
	`xTaskRemoveFromEvítLi°
–&–
pxQueue
->
xTasksWaôögToRe˚ive
 ) ) !
pdFALSE
 )

579 
	`queueYIELD_IF_USING_PREEMPTION
();

592 
	`èskEXIT_CRITICAL
();

593  
pdPASS
;

597 if–
xTicksToWaô
 =–
TickTy≥_t
 ) 0 )

601 
	`èskEXIT_CRITICAL
();

603  
îrQUEUE_EMPTY
;

605 if–
xE¡ryTimeSë
 =
pdFALSE
 )

609 
	`vTaskSëTimeOutSèã
–&
xTimeOut
 );

610 
xE¡ryTimeSë
 = 
pdTRUE
;

619 
	`èskEXIT_CRITICAL
();

624 
	`vTaskSu•ídAŒ
();

628 if–
	`xTaskCheckF‹TimeOut
–&
xTimeOut
, &
xTicksToWaô
 ) =
pdFALSE
 )

630 if–
	`¥vIsQueueEm±y
–
pxQueue
 ) !
pdFALSE
 )

634 #i‡–
c⁄figUSE_MUTEXES
 == 1 )

636 if–
pxQueue
->
uxQueueTy≥
 =
queueQUEUE_IS_MUTEX
 )

638 
	`èskENTER_CRITICAL
();

640 
	`vTaskPri‹ôyInhîô
––* ) 
pxQueue
->
pxMuãxHﬁdî
 );

642 
	`èskEXIT_CRITICAL
();

651 
	`vTaskPœ˚OnEvítLi°
–&–
pxQueue
->
xTasksWaôögToRe˚ive
 ), 
xTicksToWaô
 );

653 if–
	`xTaskResumeAŒ
(Ë=
pdFALSE
 )

655 
	`p‹tYIELD_WITHIN_API
();

666 –Ë
	`xTaskResumeAŒ
();

672 –Ë
	`xTaskResumeAŒ
();

674  
îrQUEUE_EMPTY
;

677 
	}
}

679 
Ba£Ty≥_t
 
	$¥vIsQueueFuŒ
–c⁄° 
Queue_t
 *
pxQueue
 )

681 
Ba£Ty≥_t
 
xRëu∫
;

683 
	`èskENTER_CRITICAL
();

685 if–
pxQueue
->
uxMesßgesWaôög
 =pxQueue->
uxLígth
)

687 
xRëu∫
 = 
pdTRUE
;

691 
xRëu∫
 = 
pdFALSE
;

694 
	`èskEXIT_CRITICAL
();

696  
xRëu∫
;

697 
	}
}

701 
Ba£Ty≥_t
 
	$xQueueGíîicSídFromISR
–
QueueH™dÀ_t
 
xQueue
, c⁄° * c⁄° 
pvIãmToQueue
, 
Ba£Ty≥_t
 * c⁄° 
pxHighîPri‹ôyTaskWokí
, c⁄° Ba£Ty≥_à
xC›yPosôi⁄
 )

703 
	}
}

	@queue2.h

2 
	~"li°2.h
"

3 
	~"comm⁄.h
"

4 #i‚de‡
QUEUE


5 
	#QUEUE


	)

6 * 
	tQueueH™dÀ_t
;

8 
	sQUEUE_REGISTRY_ITEM


10 c⁄° *
	mpcQueueName
;

11 
QueueH™dÀ_t
 
	mxH™dÀ
;

12 } 
	txQueueRegi°ryIãm
;

14 
	#queueYIELD_IF_USING_PREEMPTION
(Ë
	`p‹tYIELD_WITHIN_API
()

	)

16 
	#p‹tYIELD_WITHIN_API
 
p‹tYIELD


	)

17 
	#p‹tYIELD
(Ë
	`vP‹tYõld
()

	)

18 
	#xQueueSídToBackFromISR
–
xQueue
, 
pvIãmToQueue
, 
pxHighîPri‹ôyTaskWokí
 ) 
	`xQueueGíîicSídFromISR
––xQueuê), (ÖvIãmToQueuê), (ÖxHighîPri‹ôyTaskWokí ), 
queueSEND_TO_BACK
 )

	)

20 
	#èskENTER_CRITICAL
(Ë
	`p‹tENTER_CRITICAL
()

	)

21 
	#èskEXIT_CRITICAL
(Ë
	`p‹tEXIT_CRITICAL
()

	)

23 
	#p‹tENTER_CRITICAL
(Ë
	`vTaskE¡îCrôiˇl
()

	)

26 
	#p‹tEXIT_CRITICAL
(Ë
	`vTaskExôCrôiˇl
()

	)

29 
	#queueQUEUE_TYPE_BASE
 ( ( 
uöt8_t
 ) 0U )

	)

31 
	#xQueueRe˚ive
–
xQueue
, 
pvBuf„r
, 
xTicksToWaô
 ) 
	`xQueueGíîicRe˚ive
––xQueuê), (ÖvBuf„∏), ( xTicksToWaô ), 
pdFALSE
 )

	)

33 
	#xQueueCª©e
–
uxQueueLígth
, 
uxIãmSize
 ) 
	`xQueueGíîicCª©e
–uxQueueLígth, uxIãmSize, 
queueQUEUE_TYPE_BASE
 )

	)

37 
	tBa£Ty≥_t
;

39 
	tUBa£Ty≥_t
;

41 
	#c⁄figUSE_QUEUE_SETS
 0

	)

43 
	#tskIDLE_PRIORITY
 ( ( 
UBa£Ty≥_t
 ) 30U )

	)

45 
	#queueQUEUE_TYPE_BASE
 ( ( 
uöt8_t
 ) 0U )

	)

49 
	#xQueueSíd
–
xQueue
, 
pvIãmToQueue
, 
xTicksToWaô
 ) 
	`xQueueGíîicSíd
––xQueuê), (ÖvIãmToQueuê), ( xTicksToWaô ), 
queueSEND_TO_FRONT
 )

	)

50 
	#xQueueSídToBack
–
xQueue
, 
pvIãmToQueue
, 
xTicksToWaô
 ) 
	`xQueueGíîicSíd
––xQueuê), (ÖvIãmToQueuê), ( xTicksToWaô ), 
queueSEND_TO_BACK
 )

	)

52 
	#bktQUEUE_LENGTH
 ( 5 )

	)

54 
	#c⁄figQUEUE_REGISTRY_SIZE
 8

	)

55 
xQueueRegi°ryIãm
 
	tQueueRegi°ryIãm_t
;

64 
	sQueueDeföôi⁄


66 
öt8_t
 *
	mpcHód
;

67 
öt8_t
 *
	mpcTaû
;

68 
öt8_t
 *
	mpcWrôeTo
;

72 
öt8_t
 *
	mpcRódFrom
;

73 
UBa£Ty≥_t
 
	muxRecursiveCÆlCou¡
;

74 } 
	mu
;

76 
Li°_t
 
	mxTasksWaôögToSíd
;

77 
Li°_t
 
	mxTasksWaôögToRe˚ive
;

79 vﬁ©ûê
UBa£Ty≥_t
 
	muxMesßgesWaôög
;

80 
UBa£Ty≥_t
 
	muxLígth
;

81 
UBa£Ty≥_t
 
	muxIãmSize
;

83 vﬁ©ûê
Ba£Ty≥_t
 
	mxRxLock
;

84 vﬁ©ûê
Ba£Ty≥_t
 
	mxTxLock
;

86 #i‡–
c⁄figUSE_TRACE_FACILITY
 == 1 )

87 
UBa£Ty≥_t
 
	muxQueueNumbî
;

88 
uöt8_t
 
	mucQueueTy≥
;

91 #i‡–
c⁄figUSE_QUEUE_SETS
 == 1 )

92 
QueueDeföôi⁄
 *
	mpxQueueSëC⁄èöî
;

95 } 
	txQUEUE
;

96 
xQUEUE
 
	tQueue_t
;

98 
QueueH™dÀ_t
 
	gxTe°Queue
;

100 
QueueRegi°ryIãm_t
 
	gxQueueRegi°ry
[ 
c⁄figQUEUE_REGISTRY_SIZE
 ];

	@task.c

1 
	~"èsk.h
"

2 
	~"li°2.h
"

3 
	~"queue2.h
"

4 
	~"comm⁄.h
"

5 
	~"Ÿhî.h
"

6 
	#p‹tBYTE_ALIGNMENT_MASK
 (0x001f)

	)

7 vﬁ©ûê
Ba£Ty≥_t
 
	gxScheduÀrRu¬ög
 = 
pdFALSE
;

8 vﬁ©ûê
UBa£Ty≥_t
 
	guxT›RódyPri‹ôy
 = 
tskIDLE_PRIORITY
;

9 
Li°_t
 
	gpxRódyTasksLi°s
[ 
c⁄figMAX_PRIORITIES
 ];

10 
Li°_t
 
	gxDñayedTaskLi°1
;

11 
Li°_t
 
	gxDñayedTaskLi°2
;

12 
Li°_t
 * vﬁ©ûê
	gpxDñayedTaskLi°
;

13 
Li°_t
 * vﬁ©ûê
	gpxOvîÊowDñayedTaskLi°
;

14 
Li°_t
 
	gxPídögRódyLi°
;

15 vﬁ©ûê
UBa£Ty≥_t
 
	guxCuºítNumbîOfTasks
 = ( UBaseType_t ) 0U;

16 vﬁ©ûê
TickTy≥_t
 
	gxTickCou¡
 = ( TickType_t ) 0U;

17 
¥vInôüli£TaskLi°s
( );

20 
Li°_t
 
	gxSu•ídedTaskLi°
;

22 vﬁ©ûê
UBa£Ty≥_t
 
	guxPídedTicks
 = ( UBaseType_t ) 0U;

23 vﬁ©ûê
Ba£Ty≥_t
 
	gxYõldPídög
 = 
pdFALSE
;

24 vﬁ©ûê
Ba£Ty≥_t
 
	gxNumOfOvîÊows
 = ( BaseType_t ) 0;

25 
UBa£Ty≥_t
 
	guxTaskNumbî
 = ( UBaseType_t ) 0U;

26 vﬁ©ûê
TickTy≥_t
 
	gxNextTaskUnblockTime
 = ( TickType_t ) 0U;

27 
TCB_t
 * vﬁ©ûê
	gpxCuºítTCB
 = 
NULL
;

30 
TickTy≥_t
 
xTaskGëTickCou¡
( );

31 
	#¥vAddTaskToRódyLi°
–
pxTCB
 ) 
	`vLi°In£πEnd
–&–
pxRódyTasksLi°s
[ (ÖxTCB )->
uxPri‹ôy
 ] ), &––pxTCB )->
xGíîicLi°Iãm
 ))

	)

32 
Ba£Ty≥_t
 
xTaskIn¸emítTick
( );

34 
	#èskSWITCH_DELAYED_LISTS
() \

36 
Li°_t
 *
pxTemp
; \

37 
pxTemp
 = 
pxDñayedTaskLi°
; \

38 
pxDñayedTaskLi°
 = 
pxOvîÊowDñayedTaskLi°
; \

39 
pxOvîÊowDñayedTaskLi°
 = 
pxTemp
; \

40 
xNumOfOvîÊows
++; \

41 
	`¥vRe£tNextTaskUnblockTime
(); \

42 }

	)

44 
	$p‹tTASK_FUNCTION
–
¥vIdÀTask
, 
pvP¨amëîs
 )

48 if–
	`li°CURRENT_LIST_LENGTH
–&–
pxRódyTasksLi°s
[ 
tskIDLE_PRIORITY
 ] ) ) > ( 
UBa£Ty≥_t
 ) 1 )

50 
	`èskYIELD
();

53 
	}
}

56 
TickTy≥_t
 
	$xTaskGëTickCou¡
( )

58 
TickTy≥_t
 
xTicks
;

62 
xTicks
 = 
xTickCou¡
;

66  
xTicks
;

67 
	}
}

70 
	$¥vRe£tNextTaskUnblockTime
( )

72 
TCB_t
 *
pxTCB
;

74 if–
	`li°LIST_IS_EMPTY
–
pxDñayedTaskLi°
 ) !
pdFALSE
 )

80 
xNextTaskUnblockTime
 = 
p‹tMAX_DELAY
;

88 –
pxTCB
 ) = ( 
TCB_t
 * ) 
	`li°GET_OWNER_OF_HEAD_ENTRY
–
pxDñayedTaskLi°
 );

89 
xNextTaskUnblockTime
 = 
	`li°GET_LIST_ITEM_VALUE
–&––
pxTCB
 )->
xGíîicLi°Iãm
 ) );

91 
	}
}

94 
Ba£Ty≥_t
 
	$xTaskResumeAŒ
( )

96 
TCB_t
 *
pxTCB
;

97 
Ba£Ty≥_t
 
xAÃódyYõlded
 = 
pdFALSE
;

98 
	`èskENTER_CRITICAL
();

100 --
uxScheduÀrSu•íded
;

102 if–
uxScheduÀrSu•íded
 =–
UBa£Ty≥_t
 ) 
pdFALSE
 )

104 if–
uxCuºítNumbîOfTasks
 > ( 
UBa£Ty≥_t
 ) 0U )

108  
	`li°LIST_IS_EMPTY
–&
xPídögRódyLi°
 ) =
pdFALSE
 )

110 
pxTCB
 = ( 
TCB_t
 * ) 
	`li°GET_OWNER_OF_HEAD_ENTRY
––&
xPídögRódyLi°
 ) );

111 –Ë
	`uxLi°Remove
–&–
pxTCB
->
xEvítLi°Iãm
 ) );

112 –Ë
	`uxLi°Remove
–&–
pxTCB
->
xGíîicLi°Iãm
 ) );

113 
	`¥vAddTaskToRódyLi°
–
pxTCB
 );

117 if–
pxTCB
->
uxPri‹ôy
 >
pxCuºítTCB
->uxPriority )

119 
xYõldPídög
 = 
pdTRUE
;

123 if–
uxPídedTicks
 > ( 
UBa£Ty≥_t
 ) 0U )

125  
uxPídedTicks
 > ( 
UBa£Ty≥_t
 ) 0U )

127 if–
	`xTaskIn¸emítTick
(Ë!
pdFALSE
 )

129 
xYõldPídög
 = 
pdTRUE
;

131 --
uxPídedTicks
;

134 if–
xYõldPídög
 =
pdTRUE
 )

136 #if–
c⁄figUSE_PREEMPTION
 != 0 )

138 
xAÃódyYõlded
 = 
pdTRUE
;

141 
	`èskYIELD_IF_USING_PREEMPTION
();

148 
	`èskEXIT_CRITICAL
();

150  
xAÃódyYõlded
;

152 
	}
}

153 
	$¥vTaskExôEº‹
()

156 
	}
}

157 
	$¥vInôüli£TCBV¨übÀs
–
TCB_t
 * c⁄° 
pxTCB
, c⁄° * c⁄° 
pcName
, 
UBa£Ty≥_t
 
uxPri‹ôy
, c⁄° 
Mem‹yRegi⁄_t
 * c⁄° 
xRegi⁄s
, c⁄° 
uöt16_t
 
usSèckDïth
 )

159 
UBa£Ty≥_t
 
x
;

161  
x
 = ( 
UBa£Ty≥_t
 ) 0; x < ( UBa£Ty≥_àË
c⁄figMAX_TASK_NAME_LEN
; x++ )

163 
pxTCB
->
pcTaskName
[ 
x
 ] = 
pcName
[ x ];

165 if–
pcName
[ 
x
 ] == 0x00 )

171 
pxTCB
->
pcTaskName
[ 
c⁄figMAX_TASK_NAME_LEN
 - 1 ] = '\0';

173 if–
uxPri‹ôy
 >–
UBa£Ty≥_t
 ) 
c⁄figMAX_PRIORITIES
 )

175 
uxPri‹ôy
 = ( 
UBa£Ty≥_t
 ) 
c⁄figMAX_PRIORITIES
 - ( UBaseType_t ) 1U;

178 
pxTCB
->
uxPri‹ôy
 = uxPriority;

179 #i‡–
c⁄figUSE_MUTEXES
 == 1 )

181 
pxTCB
->
uxBa£Pri‹ôy
 = 
uxPri‹ôy
;

182 
pxTCB
->
uxMuãxesHñd
 = 0;

186 
	`vLi°Inôüli£Iãm
–&–
pxTCB
->
xGíîicLi°Iãm
 ) );

187 
	`vLi°Inôüli£Iãm
–&–
pxTCB
->
xEvítLi°Iãm
 ) );

189 
	`li°SET_LIST_ITEM_OWNER
–&–
pxTCB
->
xGíîicLi°Iãm
 ),ÖxTCB );

191 
	`li°SET_LIST_ITEM_VALUE
–&–
pxTCB
->
xEvítLi°Iãm
 ), ( 
TickTy≥_t
 ) 
c⁄figMAX_PRIORITIES
 - ( TickTy≥_àË
uxPri‹ôy
 );

192 
	`li°SET_LIST_ITEM_OWNER
–&–
pxTCB
->
xEvítLi°Iãm
 ),ÖxTCB );

194 #i‡–
p‹tCRITICAL_NESTING_IN_TCB
 == 1 )

196 
pxTCB
->
uxCrôiˇlNe°ög
 = ( 
UBa£Ty≥_t
 ) 0U;

200 #i‡–
c⁄figUSE_APPLICATION_TASK_TAG
 == 1 )

202 
pxTCB
->
pxTaskTag
 = 
NULL
;

206 #i‡–
c⁄figGENERATE_RUN_TIME_STATS
 == 1 )

208 
pxTCB
->
ulRunTimeCou¡î
 = 0UL;

212 #i‡–
p‹tUSING_MPU_WRAPPERS
 == 1 )

214 
	`vP‹tSt‹eTaskMPUSëtögs
–&–
pxTCB
->
xMPUSëtögs
 ), 
xRegi⁄s
,ÖxTCB->
pxSèck
, 
usSèckDïth
 );

218 –Ë
xRegi⁄s
;

219 –Ë
usSèckDïth
;

223 #if–
c⁄figNUM_THREAD_LOCAL_STORAGE_POINTERS
 != 0 )

225  
x
 = 0; x < ( 
UBa£Ty≥_t
 ) 
c⁄figNUM_THREAD_LOCAL_STORAGE_POINTERS
; x++ )

227 
pxTCB
->
pvThªadLoˇlSt‹agePoöãrs
[ 
x
 ] = 
NULL
;

232 #i‡–
c⁄figUSE_TASK_NOTIFICATIONS
 == 1 )

234 
pxTCB
->
ulNŸifõdVÆue
 = 0;

235 
pxTCB
->
eNŸifySèã
 = 
eNŸWaôögNŸifiˇti⁄
;

239 #i‡–
c⁄figUSE_NEWLIB_REENTRANT
 == 1 )

242 
	`_REENT_INIT_PTR
––&–
pxTCB
->
xNewLib_ªít
 ) ) );

245 
	}
}

246 
SèckTy≥_t
 *
	$pxP‹tInôüli£Sèck
–
SèckTy≥_t
 *
pxT›OfSèck
, 
TaskFun˘i⁄_t
 
pxCode
, *
pvP¨amëîs
 )

250 *
ç
 
	`asm
("x3");

251 
pxT›OfSèck
--;

252 *
pxT›OfSèck
 = (
p‹tSTACK_TYPE
)
pxCode
;

253 
pxT›OfSèck
 -= 22;

254 *
pxT›OfSèck
 = (
p‹tSTACK_TYPE
)
pvP¨amëîs
;

255 
pxT›OfSèck
 -= 6;

256 *
pxT›OfSèck
 = (
p‹tSTACK_TYPE
)
ç
;

257 
pxT›OfSèck
 -= 3;

258 *
pxT›OfSèck
 = (
p‹tSTACK_TYPE
)
¥vTaskExôEº‹
;

260  
pxT›OfSèck
;

261 
	}
}

263 
	#èskSELECT_HIGHEST_PRIORITY_TASK
() \

265  
	`li°LIST_IS_EMPTY
–&–
pxRódyTasksLi°s
[ 
uxT›RódyPri‹ôy
 ] ) ) ) \

267 --
uxT›RódyPri‹ôy
; \

269 
	`li°GET_OWNER_OF_NEXT_ENTRY
–
pxCuºítTCB
, &–
pxRódyTasksLi°s
[ 
uxT›RódyPri‹ôy
 ] ) ); \

270 }

	)

274 
TCB_t
 *
	$¥vAŒoˇãTCBAndSèck
–c⁄° 
uöt16_t
 
usSèckDïth
, 
SèckTy≥_t
 * c⁄° 
puxSèckBuf„r
 )

276 
TCB_t
 *
pxNewTCB
;

278 #if–
p‹tSTACK_GROWTH
 > 0 )

280 
pxNewTCB
 = ( 
TCB_t
 * ) 
	`pvP‹tMÆloc
( ( TCB_t ) );

282 if–
pxNewTCB
 !
NULL
 )

284 
pxNewTCB
->
pxSèck
 = ( 
SèckTy≥_t
 * ) 
	`pvP‹tMÆlocAlig√d
––––
size_t
 ) 
usSèckDïth
 ) * –SèckTy≥_àË), 
puxSèckBuf„r
 );

286 if–
pxNewTCB
->
pxSèck
 =
NULL
 )

288 
	`vP‹tFªe
–
pxNewTCB
 );

289 
pxNewTCB
 = 
NULL
;

295 
SèckTy≥_t
 *
pxSèck
;

297 
pxSèck
 = ( 
SèckTy≥_t
 * ) 
	`pvP‹tMÆlocAlig√d
––––
size_t
 ) 
usSèckDïth
 ) * –SèckTy≥_àË), 
puxSèckBuf„r
 );

299 if–
pxSèck
 !
NULL
 )

301 
pxNewTCB
 = ( 
TCB_t
 * ) 
	`pvP‹tMÆloc
( ( TCB_t ) );

303 if–
pxNewTCB
 !
NULL
 )

305 
pxNewTCB
->
pxSèck
 =ÖxStack;

309 
	`vP‹tFªe
–
pxSèck
 );

314 
pxNewTCB
 = 
NULL
;

319 if–
pxNewTCB
 !
NULL
 )

321 #if––
c⁄figCHECK_FOR_STACK_OVERFLOW
 > 1 ) || ( 
c⁄figUSE_TRACE_FACILITY
 =1 ) || ( 
INCLUDE_uxTaskGëSèckHighW©îM¨k
 == 1 ) )

323 –Ë
	`mem£t
–
pxNewTCB
->
pxSèck
, ( Ë
tskSTACK_FILL_BYTE
, ( 
size_t
 ) 
usSèckDïth
 * –
SèckTy≥_t
 ) );

328  
pxNewTCB
;

329 
	}
}

334 
Ba£Ty≥_t
 
	$xTaskGíîicCª©e
–
TaskFun˘i⁄_t
 
pxTaskCode
, c⁄° * c⁄° 
pcName
, c⁄° 
uöt16_t
 
usSèckDïth
,

335 * c⁄° 
pvP¨amëîs
, 
UBa£Ty≥_t
 
uxPri‹ôy
, 
TaskH™dÀ_t
 * c⁄° 
pxCª©edTask
, 
SèckTy≥_t
 * c⁄° 
puxSèckBuf„r
, c⁄° 
Mem‹yRegi⁄_t
 * c⁄° 
xRegi⁄s
 )

337 
Ba£Ty≥_t
 
xRëu∫
;

338 
TCB_t
 * 
pxNewTCB
;

339 
SèckTy≥_t
 *
pxT›OfSèck
;

343 
pxNewTCB
 = 
	`¥vAŒoˇãTCBAndSèck
–
usSèckDïth
, 
puxSèckBuf„r
 );

344 if–
pxNewTCB
 !
NULL
 )

346 #if–
p‹tUSING_MPU_WRAPPERS
 == 1 )

347 
Ba£Ty≥_t
 
xRunPrivûeged
;

348 if––
uxPri‹ôy
 & 
p‹tPRIVILEGE_BIT
 ) != 0U )

350 
xRunPrivûeged
 = 
pdTRUE
;

354 
xRunPrivûeged
 = 
pdFALSE
;

356 
uxPri‹ôy
 &~
p‹tPRIVILEGE_BIT
;

358 if–
puxSèckBuf„r
 !
NULL
 )

360 
pxNewTCB
->
xUsögSètiˇŒyAŒoˇãdSèck
 = 
pdTRUE
;

364 
pxNewTCB
->
xUsögSètiˇŒyAŒoˇãdSèck
 = 
pdFALSE
;

368 #if–
p‹tSTACK_GROWTH
 < 0 )

370 
pxT›OfSèck
 = 
pxNewTCB
->
pxSèck
 + ( 
usSèckDïth
 - ( 
uöt16_t
 ) 1 );

371 
pxT›OfSèck
 = ( 
SèckTy≥_t
 * ) ( ( ( 
p‹tPOINTER_SIZE_TYPE
 )ÖxT›OfSèck ) & ( ~––p‹tPOINTER_SIZE_TYPE ) 
p‹tBYTE_ALIGNMENT_MASK
 ) ) );

376 
pxT›OfSèck
 = 
pxNewTCB
->
pxSèck
;

378 
pxNewTCB
->
pxEndOfSèck
 =ÖxNewTCB->
pxSèck
 + ( 
usSèckDïth
 - 1 );

382 
	`¥vInôüli£TCBV¨übÀs
–
pxNewTCB
, 
pcName
, 
uxPri‹ôy
, 
xRegi⁄s
, 
usSèckDïth
 );

384 #if–
p‹tUSING_MPU_WRAPPERS
 == 1 )

386 
pxNewTCB
->
pxT›OfSèck
 = 
	`pxP‹tInôüli£Sèck
–pxT›OfSèck, 
pxTaskCode
, 
pvP¨amëîs
, 
xRunPrivûeged
 );

390 
pxNewTCB
->
pxT›OfSèck
 = 
	`pxP‹tInôüli£Sèck
–pxT›OfSèck, 
pxTaskCode
, 
pvP¨amëîs
 );

394 if––* ) 
pxCª©edTask
 !
NULL
 )

396 *
pxCª©edTask
 = ( 
TaskH™dÀ_t
 ) 
pxNewTCB
;

399 
	`èskENTER_CRITICAL
();

401 
uxCuºítNumbîOfTasks
++;

402 if–
pxCuºítTCB
 =
NULL
 )

404 
pxCuºítTCB
 = 
pxNewTCB
;

406 if–
uxCuºítNumbîOfTasks
 =–
UBa£Ty≥_t
 ) 1 )

408 
	`¥vInôüli£TaskLi°s
();

416 if–
xScheduÀrRu¬ög
 =
pdFALSE
 )

418 if–
pxCuºítTCB
->
uxPri‹ôy
 <= uxPriority )

420 
pxCuºítTCB
 = 
pxNewTCB
;

425 
uxTaskNumbî
++;

427 #i‡–
c⁄figUSE_TRACE_FACILITY
 == 1 )

430 
pxNewTCB
->
uxTCBNumbî
 = 
uxTaskNumbî
;

434 
	`¥vAddTaskToRódyLi°
(
pxNewTCB
);

436 
xRëu∫
 = 
pdPASS
;

438 
	`èskEXIT_CRITICAL
();

442 
xRëu∫
 = 
îrCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
;

445 if–
xRëu∫
 =
pdPASS
 )

447 if–
xScheduÀrRu¬ög
 !
pdFALSE
 )

453 
	`èskYIELD_IF_USING_PREEMPTION
();

458  
xRëu∫
;

459 
	}
}

463 
	$vTaskSwôchC⁄ãxt
( )

465 if–
uxScheduÀrSu•íded
 !–
UBa£Ty≥_t
 ) 
pdFALSE
 )

467 
xYõldPídög
 = 
pdTRUE
;

471 
xYõldPídög
 = 
pdFALSE
;

473 #i‡–
c⁄figGENERATE_RUN_TIME_STATS
 == 1 )

475 #ifde‡
p‹tALT_GET_RUN_TIME_COUNTER_VALUE


476 
	`p‹tALT_GET_RUN_TIME_COUNTER_VALUE
–
ulTŸÆRunTime
 );

478 
ulTŸÆRunTime
 = 
	`p‹tGET_RUN_TIME_COUNTER_VALUE
();

481 if–
ulTŸÆRunTime
 > 
ulTaskSwôchedInTime
 )

483 
pxCuºítTCB
->
ulRunTimeCou¡î
 +–
ulTŸÆRunTime
 - 
ulTaskSwôchedInTime
 );

485 
ulTaskSwôchedInTime
 = 
ulTŸÆRunTime
;

490 
	`èskCHECK_FOR_STACK_OVERFLOW
();

494 
	`èskSELECT_HIGHEST_PRIORITY_TASK
();

497 #i‡–
c⁄figUSE_NEWLIB_REENTRANT
 == 1 )

501 
_impuª_±r
 = &–
pxCuºítTCB
->
xNewLib_ªít
 );

505 
	}
}

507 
Ba£Ty≥_t
 
	$xTaskRemoveFromEvítLi°
–c⁄° 
Li°_t
 * c⁄° 
pxEvítLi°
 )

509 
TCB_t
 *
pxUnblockedTCB
;

510 
Ba£Ty≥_t
 
xRëu∫
;

511 
pxUnblockedTCB
 = ( 
TCB_t
 * ) 
	`li°GET_OWNER_OF_HEAD_ENTRY
–
pxEvítLi°
 );

512 –Ë
	`uxLi°Remove
–&–
pxUnblockedTCB
->
xEvítLi°Iãm
 ) );

514 if–
uxScheduÀrSu•íded
 =–
UBa£Ty≥_t
 ) 
pdFALSE
 )

516 –Ë
	`uxLi°Remove
–&–
pxUnblockedTCB
->
xGíîicLi°Iãm
 ) );

517 
	`¥vAddTaskToRódyLi°
–
pxUnblockedTCB
 );

524 
	`vLi°In£πEnd
–&–
xPídögRódyLi°
 ), &–
pxUnblockedTCB
->
xEvítLi°Iãm
 ) );

526 if–
pxUnblockedTCB
->
uxPri‹ôy
 > 
pxCuºítTCB
->uxPriority )

531 
xRëu∫
 = 
pdTRUE
;

535 
xYõldPídög
 = 
pdTRUE
;

539 
xRëu∫
 = 
pdFALSE
;

541  
xRëu∫
;

542 
	}
}

544 
Ba£Ty≥_t
 
	$xTaskGëScheduÀrSèã
( )

546 
Ba£Ty≥_t
 
xRëu∫
;

548 if–
xScheduÀrRu¬ög
 =
pdFALSE
 )

550 
xRëu∫
 = 
èskSCHEDULER_NOT_STARTED
;

554 if–
uxScheduÀrSu•íded
 =–
UBa£Ty≥_t
 ) 
pdFALSE
 )

556 
xRëu∫
 = 
èskSCHEDULER_RUNNING
;

560 
xRëu∫
 = 
èskSCHEDULER_SUSPENDED
;

564  
xRëu∫
;

565 
	}
}

568 
	$vTaskSu•ídAŒ
( )

570 ++
uxScheduÀrSu•íded
;

571 
	}
}

572 
	$vTaskE¡îCrôiˇl
( )

574 
	`p‹tDISABLE_INTERRUPTS
();

576 if–
xScheduÀrRu¬ög
 !
pdFALSE
 )

578 –
pxCuºítTCB
->
uxCrôiˇlNe°ög
 )++;

586 if–
pxCuºítTCB
->
uxCrôiˇlNe°ög
 == 1 )

595 
	}
}

596 
	$vTaskExôCrôiˇl
( )

598 if–
xScheduÀrRu¬ög
 !
pdFALSE
 )

600 if–
pxCuºítTCB
->
uxCrôiˇlNe°ög
 > 0U )

602 –
pxCuºítTCB
->
uxCrôiˇlNe°ög
 )--;

604 if–
pxCuºítTCB
->
uxCrôiˇlNe°ög
 == 0U )

606 
	`p‹tENABLE_INTERRUPTS
();

611 
	}
}

612 
	$vTaskSëTimeOutSèã
–
TimeOut_t
 * c⁄° 
pxTimeOut
 )

614 
pxTimeOut
->
xOvîÊowCou¡
 = 
xNumOfOvîÊows
;

615 
pxTimeOut
->
xTimeOnE¡îög
 = 
xTickCou¡
;

616 
	}
}

618 
Ba£Ty≥_t
 
	$xTaskCheckF‹TimeOut
–
TimeOut_t
 * c⁄° 
pxTimeOut
, 
TickTy≥_t
 * c⁄° 
pxTicksToWaô
 )

620 
Ba£Ty≥_t
 
xRëu∫
;

621 c⁄° 
TickTy≥_t
 
xC⁄°TickCou¡
 = 
xTickCou¡
;

622 if–*
pxTicksToWaô
 =
p‹tMAX_DELAY
 )

624 
xRëu∫
 = 
pdFALSE
;

626 if––
xNumOfOvîÊows
 !
pxTimeOut
->
xOvîÊowCou¡
 ) && ( 
xC⁄°TickCou¡
 >pxTimeOut->
xTimeOnE¡îög
 ) )

628 
xRëu∫
 = 
pdTRUE
;

630 if––
xC⁄°TickCou¡
 - 
pxTimeOut
->
xTimeOnE¡îög
 ) < *
pxTicksToWaô
 )

633 *
pxTicksToWaô
 -–
xC⁄°TickCou¡
 - 
pxTimeOut
->
xTimeOnE¡îög
 );

634 
	`vTaskSëTimeOutSèã
–
pxTimeOut
 );

635 
xRëu∫
 = 
pdFALSE
;

639 
xRëu∫
 = 
pdTRUE
;

641  
xRëu∫
;

642 
	}
}

643 
	$¥vAddCuºítTaskToDñayedLi°
–c⁄° 
TickTy≥_t
 
xTimeToWake
 )

646 
	`li°SET_LIST_ITEM_VALUE
–&–
pxCuºítTCB
->
xGíîicLi°Iãm
 ), 
xTimeToWake
 );

648 if–
xTimeToWake
 < 
xTickCou¡
 )

651 
	`vLi°In£π
–
pxOvîÊowDñayedTaskLi°
, &–
pxCuºítTCB
->
xGíîicLi°Iãm
 ) );

656 
	`vLi°In£π
–
pxDñayedTaskLi°
, &–
pxCuºítTCB
->
xGíîicLi°Iãm
 ) );

661 if–
xTimeToWake
 < 
xNextTaskUnblockTime
 )

663 
xNextTaskUnblockTime
 = 
xTimeToWake
;

666 
	}
}

668 
	$vTaskPœ˚OnEvítLi°
–
Li°_t
 * c⁄° 
pxEvítLi°
, c⁄° 
TickTy≥_t
 
xTicksToWaô
 )

670 
TickTy≥_t
 
xTimeToWake
;

671 
	`vLi°In£π
–
pxEvítLi°
, &–
pxCuºítTCB
->
xEvítLi°Iãm
 ) );

672 if–
	`uxLi°Remove
–&–
pxCuºítTCB
->
xGíîicLi°Iãm
 ) ) =–
UBa£Ty≥_t
 ) 0 )

677 if–
xTicksToWaô
 =
p‹tMAX_DELAY
 )

682 
	`vLi°In£πEnd
–&
xSu•ídedTaskLi°
, &–
pxCuºítTCB
->
xGíîicLi°Iãm
 ) );

689 
xTimeToWake
 = 
xTickCou¡
 + 
xTicksToWaô
;

690 
	`¥vAddCuºítTaskToDñayedLi°
–
xTimeToWake
 );

693 
	}
}

696 
Ba£Ty≥_t
 
	$xTaskIn¸emítTick
( )

698 
TCB_t
 * 
pxTCB
;

699 
TickTy≥_t
 
xIãmVÆue
;

700 
Ba£Ty≥_t
 
xSwôchRequúed
 = 
pdFALSE
;

701 if–
uxScheduÀrSu•íded
 =–
UBa£Ty≥_t
 ) 
pdFALSE
 )

703 ++
xTickCou¡
;

706 c⁄° 
TickTy≥_t
 
xC⁄°TickCou¡
 = 
xTickCou¡
;

708 if–
xC⁄°TickCou¡
 =–
TickTy≥_t
 ) 0U )

710 
	`èskSWITCH_DELAYED_LISTS
();

712 if–
xC⁄°TickCou¡
 >
xNextTaskUnblockTime
 )

716 if–
	`li°LIST_IS_EMPTY
–
pxDñayedTaskLi°
 ) !
pdFALSE
 )

718 
xNextTaskUnblockTime
 = 
p‹tMAX_DELAY
;

724 
pxTCB
 = ( 
TCB_t
 * ) 
	`li°GET_OWNER_OF_HEAD_ENTRY
–
pxDñayedTaskLi°
 );

725 
xIãmVÆue
 = 
	`li°GET_LIST_ITEM_VALUE
–&–
pxTCB
->
xGíîicLi°Iãm
 ) );

727 if–
xC⁄°TickCou¡
 < 
xIãmVÆue
 )

729 
xNextTaskUnblockTime
 = 
xIãmVÆue
;

732 –Ë
	`uxLi°Remove
–&–
pxTCB
->
xGíîicLi°Iãm
 ) );

736 if–
	`li°LIST_ITEM_CONTAINER
–&–
pxTCB
->
xEvítLi°Iãm
 ) ) !
NULL
 )

738 –Ë
	`uxLi°Remove
–&–
pxTCB
->
xEvítLi°Iãm
 ) );

747 
	`¥vAddTaskToRódyLi°
–
pxTCB
 );

756 if–
pxTCB
->
uxPri‹ôy
 >
pxCuºítTCB
->uxPriority )

758 
xSwôchRequúed
 = 
pdTRUE
;

771 if–
	`li°CURRENT_LIST_LENGTH
–&–
pxRódyTasksLi°s
[ 
pxCuºítTCB
->
uxPri‹ôy
 ] ) ) > ( 
UBa£Ty≥_t
 ) 1 )

773 
xSwôchRequúed
 = 
pdTRUE
;

779 ++
uxPídedTicks
;

780 if–
xYõldPídög
 !
pdFALSE
 )

782 
xSwôchRequúed
 = 
pdTRUE
;

786  
xSwôchRequúed
;

787 
	}
}

788 
	$¥vInôüli£TaskLi°s
( )

790 
UBa£Ty≥_t
 
uxPri‹ôy
;

792  
uxPri‹ôy
 = ( 
UBa£Ty≥_t
 ) 0U; uxPri‹ôy < ( UBa£Ty≥_àË
c⁄figMAX_PRIORITIES
; uxPriority++ )

794 
	`vLi°Inôüli£
–&–
pxRódyTasksLi°s
[ 
uxPri‹ôy
 ] ) );

797 
	`vLi°Inôüli£
–&
xDñayedTaskLi°1
 );

798 
	`vLi°Inôüli£
–&
xDñayedTaskLi°2
 );

799 
	`vLi°Inôüli£
–&
xPídögRódyLi°
 );

801 #i‡–
INCLUDE_vTaskDñëe
 == 1 )

803 
	`vLi°Inôüli£
–&
xTasksWaôögTîmö©i⁄
 );

807 #i‡–
INCLUDE_vTaskSu•íd
 == 1 )

809 
	`vLi°Inôüli£
–&
xSu•ídedTaskLi°
 );

815 
pxDñayedTaskLi°
 = &
xDñayedTaskLi°1
;

816 
pxOvîÊowDñayedTaskLi°
 = &
xDñayedTaskLi°2
;

817 
	}
}

818 
	$SëRu¬ög
()

820 
xScheduÀrRu¬ög
++;

822 
	}
}

825 
	$vTaskSèπScheduÀr
( )

827 
Ba£Ty≥_t
 
xRëu∫
;

828 
xRëu∫
 = 
	`xTaskCª©e
–
¥vIdÀTask
, "IDLE", 
tskIDLE_STACK_SIZE
, ( * ) 
NULL
, ( 
tskIDLE_PRIORITY
 | 
p‹tPRIVILEGE_BIT
 ), NULL );

829 if–
xRëu∫
 =
pdPASS
 )

831 
xRëu∫
 = 
	`xTimîCª©eTimîTask
();

833 if–
xRëu∫
 =
pdPASS
 )

835 
	`p‹tDISABLE_INTERRUPTS
();

836 
xNextTaskUnblockTime
 = 
p‹tMAX_DELAY
;

837 
xScheduÀrRu¬ög
 = 
pdTRUE
;

838 
xTickCou¡
 = ( 
TickTy≥_t
 ) 0U;

839 if–
	`xP‹tSèπScheduÀr
(Ë!
pdFALSE
 )

849 
	}
}

	@task.h

1 
	~"comm⁄.h
"

2 
	~"li°2.h
"

3 
	~"queue2.h
"

4 #i‚de‡
TASK


5 
	#TASK


	)

6 
	#xTaskCª©e
–
pvTaskCode
, 
pcName
, 
usSèckDïth
, 
pvP¨amëîs
, 
uxPri‹ôy
, 
pxCª©edTask
 ) 
	`xTaskGíîicCª©e
––pvTaskCodê), (ÖcNamê), ( usSèckDïth ), (ÖvP¨amëî†), ( uxPri‹ôy ), (ÖxCª©edTask ), ( 
NULL
 ), ( NULL ) )

	)

7 vﬁ©ûê
UBa£Ty≥_t
 
	guxScheduÀrSu•íded
 = ( UBa£Ty≥_àË
pdFALSE
;

8 
vTaskPœ˚OnEvítLi°
–
Li°_t
 * c⁄° 
pxEvítLi°
, c⁄° 
TickTy≥_t
 
xTicksToWaô
 );

9 * 
	tTaskH™dÀ_t
;

10 
	sxMEMORY_REGION


12 *
	mpvBa£Addªss
;

13 
uöt32_t
 
	mulLígthInByãs
;

14 
uöt32_t
 
	mulP¨amëîs
;

15 } 
	tMem‹yRegi⁄_t
;

17 
	sxTIME_OUT


19 
Ba£Ty≥_t
 
	mxOvîÊowCou¡
;

20 
TickTy≥_t
 
	mxTimeOnE¡îög
;

21 } 
	tTimeOut_t
;

22 
	#èskSCHEDULER_SUSPENDED
 ( ( 
Ba£Ty≥_t
 ) 0 )

	)

23 
	#èskSCHEDULER_NOT_STARTED
 ( ( 
Ba£Ty≥_t
 ) 1 )

	)

24 
	#èskSCHEDULER_RUNNING
 ( ( 
Ba£Ty≥_t
 ) 2 )

	)

25 
vP‹tYõld
( );

26 
	#p‹tYIELD
(Ë
	`vP‹tYõld
()

	)

28 
	#èskYIELD
(Ë
	`p‹tYIELD
()

	)

30 
	stskTaskC⁄åﬁBlock


32 vﬁ©ûê
SèckTy≥_t
 *
	mpxT›OfSèck
;

34 #i‡–
p‹tUSING_MPU_WRAPPERS
 == 1 )

35 
xMPU_SETTINGS
 
	mxMPUSëtögs
;

36 
Ba£Ty≥_t
 
	mxUsögSètiˇŒyAŒoˇãdSèck
;

39 
Li°Iãm_t
 
	mxGíîicLi°Iãm
;

40 
Li°Iãm_t
 
	mxEvítLi°Iãm
;

41 
UBa£Ty≥_t
 
	muxPri‹ôy
;

42 
SèckTy≥_t
 *
	mpxSèck
;

43 
	mpcTaskName
[ 
c⁄figMAX_TASK_NAME_LEN
 ];

45 
SèckTy≥_t
 *
	mpxEndOfSèck
;

48 #i‡–
p‹tCRITICAL_NESTING_IN_TCB
 == 1 )

49 
UBa£Ty≥_t
 
	muxCrôiˇlNe°ög
;

52 #i‡–
c⁄figUSE_TRACE_FACILITY
 == 1 )

53 
UBa£Ty≥_t
 
	muxTCBNumbî
;

54 
UBa£Ty≥_t
 
	muxTaskNumbî
;

57 #i‡–
c⁄figUSE_MUTEXES
 == 1 )

58 
UBa£Ty≥_t
 
	muxBa£Pri‹ôy
;

59 
UBa£Ty≥_t
 
	muxMuãxesHñd
;

62 #i‡–
c⁄figUSE_APPLICATION_TASK_TAG
 == 1 )

63 
TaskHookFun˘i⁄_t
 
	mpxTaskTag
;

66 #if–
c⁄figNUM_THREAD_LOCAL_STORAGE_POINTERS
 > 0 )

67 *
	mpvThªadLoˇlSt‹agePoöãrs
[ 
c⁄figNUM_THREAD_LOCAL_STORAGE_POINTERS
 ];

70 #i‡–
	tc⁄figGENERATE_RUN_TIME_STATS
 == 1 )

71 
	tuöt32_t
 
	tulRunTimeCou¡î
;

74 #i‡–
c⁄figUSE_NEWLIB_REENTRANT
 == 1 )

82 
_ªít
 
	gxNewLib_ªít
;

85 #i‡–
c⁄figUSE_TASK_NOTIFICATIONS
 == 1 )

86 vﬁ©ûê
uöt32_t
 
	gulNŸifõdVÆue
;

87 vﬁ©ûê
eNŸifyVÆue
 
	geNŸifySèã
;

90 } 
	gtskTCB
;

91 
SëRu¬ög
();

96 
tskTCB
 
	tTCB_t
;

97 
	#èskYIELD_IF_USING_PREEMPTION
(Ë
	`p‹tYIELD_WITHIN_API
()

	)

	@time.c

1 
	~"time.h
"

2 
	~"comm⁄.h
"

3 
	~"èsk.h
"

4 
	~"ícodög.h
"

5 
Li°_t
 
	gxA˘iveTimîLi°1
;

6 
Li°_t
 
	gxA˘iveTimîLi°2
;

7 
Li°_t
 *
	gpxCuºítTimîLi°
;

8 
Li°_t
 *
	gpxOvîÊowTimîLi°
;

10 
QueueH™dÀ_t
 
	gxTimîQueue
 = 
NULL
;

12 
	stmrTimîP¨amëîs


14 
TickTy≥_t
 
	mxMesßgeVÆue
;

15 
Timî_t
 * 
	mpxTimî
;

16 } 
	tTimîP¨amëî_t
;

18 
	stmrTimîQueueMesßge


20 
Ba£Ty≥_t
 
	mxMesßgeID
;

23 
TimîP¨amëî_t
 
	mxTimîP¨amëîs
;

27 #i‡–
INCLUDE_xTimîPídFun˘i⁄CÆl
 == 1 )

28 
CÆlbackP¨amëîs_t
 
	mxCÆlbackP¨amëîs
;

30 } 
	mu
;

31 } 
	tD´m⁄TaskMesßge_t
;

35 
¥vPro˚ssTimîOrBlockTask
–c⁄° 
TickTy≥_t
 
xNextExpúeTime
, 
Ba£Ty≥_t
 
xLi°WasEm±y
 );

36 
	$¥vSëNextTimîI¡îru±
()

38 
__asm
 vﬁ©ûe("ldÅ0,0(%0)"::"r"
mtimecmp
);

39 
__asm
 vﬁ©ûe("addÅ0,t0,%0" :: "r"(
c⁄figTICK_CLOCK_HZ
 / 
c⁄figTICK_RATE_HZ
));

40 
__asm
 vﬁ©ûe("sd %0,0—0)"::"r"
mtimecmp
);

41 
	}
}

44 
	$vP‹tSëupTimî
()

46 
__asm
 vﬁ©ûe("ldÅ0,0(%0)"::"r"
mtimecmp
);

47 
__asm
 vﬁ©ûe("addÅ0,t0,%0"::"r"(
c⁄figTICK_CLOCK_HZ
 / 
c⁄figTICK_RATE_HZ
));

48 
__asm
 vﬁ©ûe("sd %0,0—0)"::"r"
mtimecmp
);

51 
__asm
 volatile("csrs mie,%0"::"r"(0x80));

52 
	}
}

54 
	$vP‹tSysTickH™dÀr
( )

56 
	`¥vSëNextTimîI¡îru±
();

59 if–
	`xTaskIn¸emítTick
(Ë!
pdFALSE
 )

61 
	`vTaskSwôchC⁄ãxt
();

63 
	}
}

64 
	$¥vCheckF‹VÆidLi°AndQueue
( )

66 if–
xTimîQueue
 =
NULL
 )

68 
	`vLi°Inôüli£
–&
xA˘iveTimîLi°1
 );

69 
	`vLi°Inôüli£
–&
xA˘iveTimîLi°2
 );

70 
pxCuºítTimîLi°
 = &
xA˘iveTimîLi°1
;

71 
pxOvîÊowTimîLi°
 = &
xA˘iveTimîLi°2
;

72 
xTimîQueue
 = 
	`xQueueCª©e
––
UBa£Ty≥_t
 ) 
c⁄figTIMER_QUEUE_LENGTH
, –
D´m⁄TaskMesßge_t
 ) );

74 if–
xTimîQueue
 !
NULL
 )

76 
	`vQueueAddToRegi°ry
–
xTimîQueue
, "TmrQ" );

80 
	}
}

81 
TimîH™dÀ_t
 
	$xTimîCª©e
–c⁄° * c⁄° 
pcTimîName
, c⁄° 
TickTy≥_t
 
xTimîPîiodInTicks
, c⁄° 
UBa£Ty≥_t
 
uxAutoRñﬂd
, * c⁄° 
pvTimîID
, 
TimîCÆlbackFun˘i⁄_t
 
pxCÆlbackFun˘i⁄
 )

83 
Timî_t
 *
pxNewTimî
;

84 if–
xTimîPîiodInTicks
 =–
TickTy≥_t
 ) 0U )

86 
pxNewTimî
 = 
NULL
;

90 
pxNewTimî
 = ( 
Timî_t
 * ) 
	`pvP‹tMÆloc
( ( Timer_t ) );

91 if–
pxNewTimî
 !
NULL
 )

95 
	`¥vCheckF‹VÆidLi°AndQueue
();

98 
pxNewTimî
->
pcTimîName
 =ÖcTimerName;

99 
pxNewTimî
->
xTimîPîiodInTicks
 = xTimerPeriodInTicks;

100 
pxNewTimî
->
uxAutoRñﬂd
 = uxAutoReload;

101 
pxNewTimî
->
pvTimîID
 =ÖvTimerID;

102 
pxNewTimî
->
pxCÆlbackFun˘i⁄
 =ÖxCallbackFunction;

103 
	`vLi°Inôüli£Iãm
–&–
pxNewTimî
->
xTimîLi°Iãm
 ) );

112  ( 
TimîH™dÀ_t
 ) 
pxNewTimî
;

114 
	}
}

116 
TickTy≥_t
 
	$¥vGëNextExpúeTime
–
Ba£Ty≥_t
 * c⁄° 
pxLi°WasEm±y
 )

118 
TickTy≥_t
 
xNextExpúeTime
;

127 *
pxLi°WasEm±y
 = 
	`li°LIST_IS_EMPTY
–
pxCuºítTimîLi°
 );

128 if–*
pxLi°WasEm±y
 =
pdFALSE
 )

130 
xNextExpúeTime
 = 
	`li°GET_ITEM_VALUE_OF_HEAD_ENTRY
–
pxCuºítTimîLi°
 );

135 
xNextExpúeTime
 = ( 
TickTy≥_t
 ) 0U;

138  
xNextExpúeTime
;

139 
	}
}

141 
	$¥vTimîTask
–*
pvP¨amëîs
 )

143 
TickTy≥_t
 
xNextExpúeTime
;

144 
Ba£Ty≥_t
 
xLi°WasEm±y
;

149 
xNextExpúeTime
 = 
	`¥vGëNextExpúeTime
–&
xLi°WasEm±y
 );

153 
	`¥vPro˚ssTimîOrBlockTask
–
xNextExpúeTime
, 
xLi°WasEm±y
 );

156 
	`¥vPro˚ssRe˚ivedComm™ds
();

158 
	}
}

161 
TickTy≥_t
 
	$¥vSam∂eTimeNow
–
Ba£Ty≥_t
 * c⁄° 
pxTimîLi°sWîeSwôched
 )

163 
TickTy≥_t
 
xTimeNow
;

164 
TickTy≥_t
 
xLa°Time
 = ( TickType_t ) 0U;

166 
xTimeNow
 = 
	`xTaskGëTickCou¡
();

168 if–
xTimeNow
 < 
xLa°Time
 )

170 
	`¥vSwôchTimîLi°s
();

171 *
pxTimîLi°sWîeSwôched
 = 
pdTRUE
;

175 *
pxTimîLi°sWîeSwôched
 = 
pdFALSE
;

178 
xLa°Time
 = 
xTimeNow
;

180  
xTimeNow
;

181 
	}
}

184 
	$¥vPro˚ssTimîOrBlockTask
–c⁄° 
TickTy≥_t
 
xNextExpúeTime
, 
Ba£Ty≥_t
 
xLi°WasEm±y
 )

186 
TickTy≥_t
 
xTimeNow
;

187 
Ba£Ty≥_t
 
xTimîLi°sWîeSwôched
;

188 
xTimeNow
 = 
	`¥vSam∂eTimeNow
–&
xTimîLi°sWîeSwôched
 );

189 if–
xTimîLi°sWîeSwôched
 =
pdFALSE
 )

192 if––
xLi°WasEm±y
 =
pdFALSE
 ) && ( 
xNextExpúeTime
 <
xTimeNow
 ) )

194 –Ë
	`xTaskResumeAŒ
();

195 
	`¥vPro˚ssExpúedTimî
–
xNextExpúeTime
, 
xTimeNow
 );

199 if–
xLi°WasEm±y
 !
pdFALSE
 )

201 
xLi°WasEm±y
 = 
	`li°LIST_IS_EMPTY
–
pxOvîÊowTimîLi°
 );

204 
	`vQueueWaôF‹MesßgeRe°ri˘ed
–
xTimîQueue
, ( 
xNextExpúeTime
 - 
xTimeNow
 ), 
xLi°WasEm±y
 );

206 if–
	`xTaskResumeAŒ
(Ë=
pdFALSE
 )

208 
	`p‹tYIELD_WITHIN_API
();

212 
	}
}

217 
Ba£Ty≥_t
 
	$xTimîGíîicComm™d
–
TimîH™dÀ_t
 
xTimî
, c⁄° 
Ba£Ty≥_t
 
xComm™dID
, c⁄° 
TickTy≥_t
 
xO±i⁄ÆVÆue
, Ba£Ty≥_à* c⁄° 
pxHighîPri‹ôyTaskWokí
, c⁄° TickTy≥_à
xTicksToWaô
 )

219 
Ba£Ty≥_t
 
xRëu∫
 = 
pdFAIL
;

220 
D´m⁄TaskMesßge_t
 
xMesßge
;

221 if–
xTimîQueue
 !
NULL
 )

224 
xMesßge
.
xMesßgeID
 = 
xComm™dID
;

225 
xMesßge
.
u
.
xTimîP¨amëîs
.
xMesßgeVÆue
 = 
xO±i⁄ÆVÆue
;

226 
xMesßge
.
u
.
xTimîP¨amëîs
.
pxTimî
 = ( 
Timî_t
 * ) 
xTimî
;

228 if–
xComm™dID
 < 
tmrFIRST_FROM_ISR_COMMAND
 )

230 if–
	`xTaskGëScheduÀrSèã
(Ë=
èskSCHEDULER_RUNNING
 )

232 
xRëu∫
 = 
	`xQueueSídToBack
–
xTimîQueue
, &
xMesßge
, 
xTicksToWaô
 );

236 
xRëu∫
 = 
	`xQueueSídToBack
–
xTimîQueue
, &
xMesßge
, 0 );

241 
xRëu∫
 = 
	`xQueueSídToBackFromISR
–
xTimîQueue
, &
xMesßge
, 
pxHighîPri‹ôyTaskWokí
 );

244  
xRëu∫
;

245 
	}
}

246 
Ba£Ty≥_t
 
	$xTimîCª©eTimîTask
( )

249 
Ba£Ty≥_t
 
xRëu∫
 = 
pdFAIL
;

250 
	`¥vCheckF‹VÆidLi°AndQueue
();

251 if–
xTimîQueue
 !
NULL
 )

253 
xRëu∫
 = 
	`xTaskCª©e
–
¥vTimîTask
, "Tm∏Svc", ( 
uöt16_t
 ) 
c⁄figTIMER_TASK_STACK_DEPTH
, 
NULL
, ( ( 
UBa£Ty≥_t
 ) 
c⁄figTIMER_TASK_PRIORITY
 ) | 
p‹tPRIVILEGE_BIT
, NULL);

255  
xRëu∫
;

256 
	}
}

261 
	$¥vPro˚ssRe˚ivedComm™ds
( )

263 
D´m⁄TaskMesßge_t
 
xMesßge
;

264 
Timî_t
 *
pxTimî
;

265 
Ba£Ty≥_t
 
xTimîLi°sWîeSwôched
, 
xResu…
;

266 
TickTy≥_t
 
xTimeNow
;

268  
	`xQueueRe˚ive
–
xTimîQueue
, &
xMesßge
, 
tmrNO_DELAY
 ) !
pdFAIL
 )

270 #i‡–
INCLUDE_xTimîPídFun˘i⁄CÆl
 == 1 )

272 if–
xMesßge
.
xMesßgeID
 < ( 
Ba£Ty≥_t
 ) 0 )

274 c⁄° 
CÆlbackP¨amëîs_t
 * c⁄° 
pxCÆlback
 = &–
xMesßge
.
u
.
xCÆlbackP¨amëîs
 );

276 
	`c⁄figASSERT
–
pxCÆlback
 );

278 
pxCÆlback
->
	`pxCÆlbackFun˘i⁄
–pxCÆlback->
pvP¨amëî1
,ÖxCÆlback->
ulP¨amëî2
 );

282 
	`mtCOVERAGE_TEST_MARKER
();

286 if–
xMesßge
.
xMesßgeID
 >–
Ba£Ty≥_t
 ) 0 )

288 
pxTimî
 = 
xMesßge
.
u
.
xTimîP¨amëîs
.pxTimer;

290 if–
	`li°IS_CONTAINED_WITHIN
–
NULL
, &–
pxTimî
->
xTimîLi°Iãm
 ) ) =
pdFALSE
 )

292 –Ë
	`uxLi°Remove
–&–
pxTimî
->
xTimîLi°Iãm
 ) );

296 
	`mtCOVERAGE_TEST_MARKER
();

299 
xTimeNow
 = 
	`¥vSam∂eTimeNow
–&
xTimîLi°sWîeSwôched
 );

301  
xMesßge
.
xMesßgeID
 )

303 
tmrCOMMAND_START
 :

304 
tmrCOMMAND_START_FROM_ISR
 :

305 
tmrCOMMAND_RESET
 :

306 
tmrCOMMAND_RESET_FROM_ISR
 :

307 
tmrCOMMAND_START_DONT_TRACE
 :

308 if–
	`¥vIn£πTimîInA˘iveLi°
–
pxTimî
, 
xMesßge
.
u
.
xTimîP¨amëîs
.
xMesßgeVÆue
 +ÖxTimî->
xTimîPîiodInTicks
, 
xTimeNow
, xMesßge.u.xTimîP¨amëîs.xMesßgeVÆuêË=
pdTRUE
 )

310 
pxTimî
->
	`pxCÆlbackFun˘i⁄
––
TimîH™dÀ_t
 )ÖxTimer );

311 
	`åa˚TIMER_EXPIRED
–
pxTimî
 );

313 if–
pxTimî
->
uxAutoRñﬂd
 =–
UBa£Ty≥_t
 ) 
pdTRUE
 )

315 
xResu…
 = 
	`xTimîGíîicComm™d
–
pxTimî
, 
tmrCOMMAND_START_DONT_TRACE
, 
xMesßge
.
u
.
xTimîP¨amëîs
.
xMesßgeVÆue
 +ÖxTimî->
xTimîPîiodInTicks
, 
NULL
, 
tmrNO_DELAY
 );

316 
	`c⁄figASSERT
–
xResu…
 );

317 –Ë
xResu…
;

321 
	`mtCOVERAGE_TEST_MARKER
();

326 
	`mtCOVERAGE_TEST_MARKER
();

330 
tmrCOMMAND_STOP
 :

331 
tmrCOMMAND_STOP_FROM_ISR
 :

334 
tmrCOMMAND_CHANGE_PERIOD
 :

335 
tmrCOMMAND_CHANGE_PERIOD_FROM_ISR
 :

336 
pxTimî
->
xTimîPîiodInTicks
 = 
xMesßge
.
u
.
xTimîP¨amëîs
.
xMesßgeVÆue
;

337 
	`c⁄figASSERT
––
pxTimî
->
xTimîPîiodInTicks
 > 0 ) );

339 –Ë
	`¥vIn£πTimîInA˘iveLi°
–
pxTimî
, ( 
xTimeNow
 +ÖxTimî->
xTimîPîiodInTicks
 ), xTimeNow, xTimeNow );

341 
tmrCOMMAND_DELETE
 :

342 
	`vP‹tFªe
–
pxTimî
 );

350 
	}
}

	@time.h

1 
	~"comm⁄.h
"

2 
	~"li°2.h
"

3 
	#CSR_MIE
 (0x304)

	)

4 
	#CSR_MTVEC
 (0x305)

	)

5 
	#mtimecmp
 (0x2004000)

	)

6 
	#mtime
 (0x200bff8)

	)

8 
	#c⁄figTICK_CLOCK_HZ
 ( ( Ë1000000 )

	)

9 
	#c⁄figTICK_RATE_HZ
 ( ( 
TickTy≥_t
 ) 1000 )

	)

11 
	#tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR
 ( ( 
Ba£Ty≥_t
 ) -2 )

	)

12 
	#tmrCOMMAND_EXECUTE_CALLBACK
 ( ( 
Ba£Ty≥_t
 ) -1 )

	)

13 
	#tmrCOMMAND_START_DONT_TRACE
 ( ( 
Ba£Ty≥_t
 ) 0 )

	)

14 
	#tmrCOMMAND_START
 ( ( 
Ba£Ty≥_t
 ) 1 )

	)

15 
	#tmrCOMMAND_RESET
 ( ( 
Ba£Ty≥_t
 ) 2 )

	)

16 
	#tmrCOMMAND_STOP
 ( ( 
Ba£Ty≥_t
 ) 3 )

	)

17 
	#tmrCOMMAND_CHANGE_PERIOD
 ( ( 
Ba£Ty≥_t
 ) 4 )

	)

18 
	#tmrCOMMAND_DELETE
 ( ( 
Ba£Ty≥_t
 ) 5 )

	)

20 
	#tmrFIRST_FROM_ISR_COMMAND
 ( ( 
Ba£Ty≥_t
 ) 6 )

	)

21 
	#tmrCOMMAND_START_FROM_ISR
 ( ( 
Ba£Ty≥_t
 ) 6 )

	)

22 
	#tmrCOMMAND_RESET_FROM_ISR
 ( ( 
Ba£Ty≥_t
 ) 7 )

	)

23 
	#tmrCOMMAND_STOP_FROM_ISR
 ( ( 
Ba£Ty≥_t
 ) 8 )

	)

24 
	#tmrCOMMAND_CHANGE_PERIOD_FROM_ISR
 ( ( 
Ba£Ty≥_t
 ) 9 )

	)

26 * 
	tTimîH™dÀ_t
;

27 (*
	tTimîCÆlbackFun˘i⁄_t
)–
	tTimîH™dÀ_t
 
	txTimî
 );

28 
	stmrTimîC⁄åﬁ


30 c⁄° *
pcTimîName
;

31 
Li°Iãm_t
 
xTimîLi°Iãm
;

32 
TickTy≥_t
 
xTimîPîiodInTicks
;

33 
UBa£Ty≥_t
 
uxAutoRñﬂd
;

34 *
pvTimîID
;

35 
TimîCÆlbackFun˘i⁄_t
 
pxCÆlbackFun˘i⁄
;

36 #if–
c⁄figUSE_TRACE_FACILITY
 == 1 )

37 
UBa£Ty≥_t
 
uxTimîNumbî
;

39 } 
	txTIMER
;

40 
xTIMER
 
	tTimî_t
;

42 
	#xTimîSèπ
–
xTimî
, 
xTicksToWaô
 ) 
	`xTimîGíîicComm™d
––xTimî ), 
tmrCOMMAND_START
, ( 
	`xTaskGëTickCou¡
(Ë), 
NULL
, ( xTicksToWaô ) )

	)

	@
1
.
1
/usr/include
15
122
common.c
common.h
encoding.h
heap2.c
heap2.h
list2.c
list2.h
main.c
other.h
queue2.c
queue2.h
task.c
task.h
time.c
time.h
