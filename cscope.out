cscope 15 /work_base/TROS_change -q 0000000431 0000045930
	@common.c

1 
	~"commÚ.h
"

2 
	$memıy
(* 
des
 , * 
¤c
, 
numb”
)

4 *
tmp
 = 
des
;

5 * 
tmp2
 = 
¤c
;

6 
i
 = 0; i< 
numb”
; i++)

8 *
tmp
++ = *
tmp2
++;

10 
	}
}

	@common.h

1 #iâdeà
zzy


2 
	#zzy


	)

3 
	#št8_t
 

	)

4 
	#pÜtCRITICAL_NESTING_IN_TCB
 1

	)

5 
	#queueQUEUE_TYPE_BASE
 ( ( 
ušt8_t
 ) 0U )

	)

6 
	#cÚfigUSE_QUEUE_SETS
 0

	)

8 
	#queueQUEUE_TYPE_BASE
 ( ( 
ušt8_t
 ) 0U )

	)

10 
	#bktQUEUE_LENGTH
 ( 5 )

	)

11 
	#size_t
 

	)

12 
	#ušt8_t
 

	)

13 
	#NULL
 0

	)

14 
	#pÜtPOINTER_SIZE_TYPE
 

	)

15 
	#ušt16_t
 

	)

16 
	#boŞ
 

	)

17 
	#çl£
 ()0

	)

18 
	#Œue
 ()1

	)

19 
	#cÚfigQUEUE_REGISTRY_SIZE
 8

	)

20 
	#ušt32_t
 

	)

21 
	#ušt64_t
 

	)

22 
	tUBa£Ty³_t
;

23 
	tBa£Ty³_t
;

24 * 
	tQueueHªdË_t
;

25 
ušt32_t
 
	tTickTy³_t
;

26 
	#cÚfigTIMER_QUEUE_LENGTH
 2

	)

27 
	#pÜtMAX_DELAY
 ( 
TickTy³_t
 ) 0xffffffffUL

	)

28 
	#pdFALSE
 
çl£


	)

29 
	#pdTRUE
 
Œue


	)

30 
	#pdPASS
 ( 
pdTRUE
 )

	)

31 
	#queueSEND_TO_BACK
 ( ( 
Ba£Ty³_t
 ) 0 )

	)

32 
	#queueSEND_TO_FRONT
 ( ( 
Ba£Ty³_t
 ) 1 )

	)

33 
	#queueOVERWRITE
 ( ( 
Ba£Ty³_t
 ) 2 )

	)

35 
	#cÚfigMAX_PRIORITIES
 ( 5 )

	)

36 
	#pÜtYIELD_WITHIN_API
 
pÜtYIELD


	)

37 
	#pÜtYIELD
(è
	`vPÜtY›ld
()

	)

38 
	#SckTy³_t
 
ušt32_t


	)

39 
	#cÚfigMAX_TASK_NAME_LEN
 ( 16 )

	)

40 
	#”rQUEUE_EMPTY
 ( ( 
Ba£Ty³_t
 ) 0 )

	)

41 
	#”rQUEUE_FULL
 ( ( 
Ba£Ty³_t
 ) 0 )

	)

42 (*
	tTaskFunùiÚ_t
)( * );

43 
	#”rCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
 ( -1 )

	)

44 
	#”rQUEUE_BLOCKED
 ( -4 )

	)

45 
	#”rQUEUE_YIELD
 ( -5 )

	)

46 
	#pÜtSTACK_TYPE
 
ušt64_t


	)

47 
	#pdFAIL
 ( 
pdFALSE
 )

	)

48 
	#cÚfigMINIMAL_STACK_SIZE
 ( ( è1024 )

	)

49 
	#cÚfigTIMER_TASK_STACK_DEPTH
 ( 
cÚfigMINIMAL_STACK_SIZE
 )

	)

50 
	#cÚfigTIMER_TASK_PRIORITY
 ( 2 )

	)

52 
	#pÜtPRIVILEGE_BIT
 ( ( 
UBa£Ty³_t
 ) 0x00 )

	)

53 
	#skYIELD_IF_USING_PREEMPTION
(è
	`pÜtYIELD_WITHIN_API
()

	)

54 
	#pvPÜtM®locAligÃd
Ğ
x
, 
puxSckBufãr
 ) ( ( (…uxSckBufã¸è=ğ
NULL
 ) ? ( 
	`pvPÜtM®loc
ĞĞx ) ) ) : (…uxSckBufã¸è)

	)

56 
	#pÜtSTACK_GROWTH
 ( -1 )

	)

57 
	#pÜtDISABLE_INTERRUPTS
(è
__asm
 vŞ©Ğ"c¤øm¡©us,1" )

	)

58 
	#pÜtENABLE_INTERRUPTS
(è
__asm
 vŞ©Ğ"c¤ m¡©us,1" )

	)

	@encoding.h

1 #ifdeà
__riscv_xË


2 
	#STORE
 
sd


	)

3 
	#LOAD
 
ld


	)

4 
	#REGBYTES
 8

	)

6 
	#STORE
 
sw


	)

7 
	#LOAD
 
lw


	)

8 
	#REGBYTES
 4

	)

	@heap2.c

1 
	~"h—p2.h
"

2 
	#pÜtBYTE_ALIGNMENT
 8

	)

3 
	#cÚfigTOTAL_HEAP_SIZE
 ( ( 
size_t
 ) ( 100 * 1024 ) )

	)

4 
	#pÜtBYTE_ALIGNMENT_MASK
 ( 0x0007 )

	)

6 
	sA_BLOCK_LINK


8 
A_BLOCK_LINK
 *
	mpxNextF»eBlock
;

9 
size_t
 
	mxBlockSize
;

10 } 
	tBlockLšk_t
;

14 
BlockLšk_t
 
	gxS¹
, 
	gxEnd
;

18 
ušt8_t
 
	gucH—p
[ 
cÚfigTOTAL_HEAP_SIZE
 ];

23 
	#cÚfigADJUSTED_HEAP_SIZE
 ( 
cÚfigTOTAL_HEAP_SIZE
 - 
pÜtBYTE_ALIGNMENT
 )

	)

25 
size_t
 
	gxF»eBy‹sRemaššg
 = 
cÚfigADJUSTED_HEAP_SIZE
;

36 
	#´vIn£¹BlockIÁoF»eLi¡
Ğ
pxBlockToIn£¹
 ) \

38 
BlockLšk_t
 *
pxI‹¿tÜ
; \

39 
size_t
 
xBlockSize
; \

41 
xBlockSize
 = 
pxBlockToIn£¹
->xBlockSize; \

45  
pxI‹¿tÜ
 = &
xS¹
;…xI‹¿tÜ->
pxNextF»eBlock
->
xBlockSize
 < xBlockSize;…xIterator =…xIterator->pxNextFreeBlock ) \

52 
pxBlockToIn£¹
->
pxNextF»eBlock
 = 
pxI‹¿tÜ
->pxNextFreeBlock; \

53 
pxI‹¿tÜ
->
pxNextF»eBlock
 = 
pxBlockToIn£¹
; \

54 }

	)

57 cÚ¡ 
ušt16_t
 
	gh—pSTRUCT_SIZE
 = ( (  ( 
BlockLšk_t
 ) + ( 
pÜtBYTE_ALIGNMENT
 - 1 ) ) & ~
pÜtBYTE_ALIGNMENT_MASK
 );

58 
	$´vH—pIn™
( )

60 
BlockLšk_t
* 
pxFœ¡F»eBlock
;

61 
ušt8_t
 *
pucAligÃdH—p
;

62 
pucAligÃdH—p
 = (
ušt8_t
*)(((
pÜtPOINTER_SIZE_TYPE
)&
ucH—p
[
pÜtBYTE_ALIGNMENT
])&(~(ÕÜtPOINTER_SIZE_TYPE)
pÜtBYTE_ALIGNMENT_MASK
 ) ) );

64 
xS¹
.
pxNextF»eBlock
 = (*)
pucAligÃdH—p
;

65 
xS¹
.
xBlockSize
 = 0;

67 
xEnd
.
pxNextF»eBlock
 = 
NULL
;

68 
xEnd
.
xBlockSize
 = 
cÚfigADJUSTED_HEAP_SIZE
;

72 
pxFœ¡F»eBlock
 = ( * ) 
pucAligÃdH—p
;

73 
pxFœ¡F»eBlock
->
xBlockSize
 = 
cÚfigADJUSTED_HEAP_SIZE
;

74 
pxFœ¡F»eBlock
->
pxNextF»eBlock
 = &
xEnd
;

76 
	}
}

79 *
	$pvPÜtM®loc
Ğ
size_t
 
xWª‹dSize
 )

81 
BlockLšk_t
 *
pxBlock
, *
pxP»viousBlock
, *
pxNewBlockLšk
;

82 
boŞ
 
xH—pHasB“nIn™Ÿli£d
 = 
çl£
;

83 *
pvR‘uº
 = 
NULL
;

85 ifĞ
xH—pHasB“nIn™Ÿli£d
 =ğ
çl£
)

87 
	`´vH—pIn™
();

88 
xH—pHasB“nIn™Ÿli£d
 = 
Œue
;

93 ifĞ
xWª‹dSize
 > 0 )

95 
xWª‹dSize
 +ğ
h—pSTRUCT_SIZE
;

98 ifĞĞ
xWª‹dSize
 & 
pÜtBYTE_ALIGNMENT_MASK
 ) != 0 )

101 
xWª‹dSize
 +ğĞ
pÜtBYTE_ALIGNMENT
 - ( xWª‹dSiz& 
pÜtBYTE_ALIGNMENT_MASK
 ) );

106 ifĞĞ
xWª‹dSize
 > 0 ) && ( xWª‹dSiz< 
cÚfigADJUSTED_HEAP_SIZE
 ) )

110 
pxP»viousBlock
 = &
xS¹
;

111 
pxBlock
 = 
xS¹
.
pxNextF»eBlock
;

112  ( 
pxBlock
->
xBlockSize
 < 
xWª‹dSize
 ) && (…xBlock->
pxNextF»eBlock
 !ğ
NULL
 ) )

114 
pxP»viousBlock
 = 
pxBlock
;

115 
pxBlock
 =…xBlock->
pxNextF»eBlock
;

119 ifĞ
pxBlock
 !ğ&
xEnd
 )

123 
pvR‘uº
 = ( * ) ( ( ( 
ušt8_t
 * ) 
pxP»viousBlock
->
pxNextF»eBlock
 ) + 
h—pSTRUCT_SIZE
 );

127 
pxP»viousBlock
->
pxNextF»eBlock
 = 
pxBlock
->pxNextFreeBlock;

130 ifĞĞ
pxBlock
->
xBlockSize
 - 
xWª‹dSize
 ) > 
h—pMINIMUM_BLOCK_SIZE
 )

135 
pxNewBlockLšk
 = ( * ) ( ( ( 
ušt8_t
 * ) 
pxBlock
 ) + 
xWª‹dSize
 );

139 
pxNewBlockLšk
->
xBlockSize
 = 
pxBlock
->xBlockSiz- 
xWª‹dSize
;

140 
pxBlock
->
xBlockSize
 = 
xWª‹dSize
;

143 
	`´vIn£¹BlockIÁoF»eLi¡
ĞĞ
pxNewBlockLšk
 ) );

146 
xF»eBy‹sRemaššg
 -ğ
pxBlock
->
xBlockSize
;

151  
pvR‘uº
;

153 
	}
}

154 
	$vPÜtF»e
Ğ*
pv
 )

156 
ušt8_t
 *
puc
 = ( ušt8_ˆ* ) 
pv
;

157 
BlockLšk_t
 *
pxLšk
;

158 ifĞ
pv
 !ğ
NULL
 )

162 
puc
 -ğ
h—pSTRUCT_SIZE
;

166 
pxLšk
 = ( * ) 
puc
;

169 
	`´vIn£¹BlockIÁoF»eLi¡
ĞĞĞ
BlockLšk_t
 * ) 
pxLšk
 ) );

170 
xF»eBy‹sRemaššg
 +ğ
pxLšk
->
xBlockSize
;

173 
	}
}

	@heap2.h

1 
	#size_t
 

	)

2 
	#ušt8_t
 

	)

3 
	#NULL
 0

	)

4 
	#pÜtPOINTER_SIZE_TYPE
 

	)

5 
	#ušt16_t
 

	)

6 
	#boŞ
 

	)

7 
	#çl£
 ()0

	)

8 
	#Œue
 ()1

	)

9 
	#h—pMINIMUM_BLOCK_SIZE
 ( ( 
size_t
 ) ( 
h—pSTRUCT_SIZE
 * 2 ) )

	)

10 *
pvPÜtM®loc
Ğ
size_t
 
xWª‹dSize
 );

11 
vPÜtF»e
Ğ*
pv
 );

	@list2.c

1 
	~"li¡2.h
"

2 
	~"commÚ.h
"

3 
	$vLi¡In™Ÿli£
Ğ
Li¡_t
 * cÚ¡ 
pxLi¡
 )

8 
pxLi¡
->
pxIndex
 = ( 
Li¡I‹m_t
 * ) &ĞpxLi¡->
xLi¡End
 );

12 
pxLi¡
->
xLi¡End
.
xI‹mV®ue
 = 
pÜtMAX_DELAY
;

16 
pxLi¡
->
xLi¡End
.
pxNext
 = ( 
Li¡I‹m_t
 * ) &(…xList->xListEnd );

17 
pxLi¡
->
xLi¡End
.
pxP»vious
 = ( 
Li¡I‹m_t
 * ) &(…xList->xListEnd );

19 
pxLi¡
->
uxNumb”OfI‹ms
 = ( 
UBa£Ty³_t
 ) 0U;

25 
	}
}

27 
	$vLi¡In™Ÿli£I‹m
Ğ
Li¡I‹m_t
 * cÚ¡ 
pxI‹m
 )

30 
pxI‹m
->
pvCÚš”
 = 
NULL
;

36 
	}
}

39 
	$vLi¡In£¹
Ğ
Li¡_t
 * cÚ¡ 
pxLi¡
, 
Li¡I‹m_t
 * cÚ¡ 
pxNewLi¡I‹m
 )

41 
Li¡I‹m_t
 *
pxI‹¿tÜ
;

42 cÚ¡ 
TickTy³_t
 
xV®ueOfIn£¹iÚ
 = 
pxNewLi¡I‹m
->
xI‹mV®ue
;

58 ifĞ
xV®ueOfIn£¹iÚ
 =ğ
pÜtMAX_DELAY
 )

60 
pxI‹¿tÜ
 = 
pxLi¡
->
xLi¡End
.
pxP»vious
;

87  
pxI‹¿tÜ
 = ( 
Li¡I‹m_t
 * ) &Ğ
pxLi¡
->
xLi¡End
 );…xI‹¿tÜ->
pxNext
->
xI‹mV®ue
 <ğ
xV®ueOfIn£¹iÚ
;…xIterator =…xIterator->pxNext )

94 
pxNewLi¡I‹m
->
pxNext
 = 
pxI‹¿tÜ
->pxNext;

95 
pxNewLi¡I‹m
->
pxNext
->
pxP»vious
 =…xNewListItem;

96 
pxNewLi¡I‹m
->
pxP»vious
 = 
pxI‹¿tÜ
;

97 
pxI‹¿tÜ
->
pxNext
 = 
pxNewLi¡I‹m
;

101 
pxNewLi¡I‹m
->
pvCÚš”
 = ( * ) 
pxLi¡
;

103 Ğ
pxLi¡
->
uxNumb”OfI‹ms
 )++;

104 
	}
}

106 
	$vLi¡In£¹End
Ğ
Li¡_t
 * cÚ¡ 
pxLi¡
, 
Li¡I‹m_t
 * cÚ¡ 
pxNewLi¡I‹m
 )

108 
Li¡I‹m_t
 * cÚ¡ 
pxIndex
 = 
pxLi¡
->pxIndex;

119 
pxNewLi¡I‹m
->
pxNext
 = 
pxIndex
;

120 
pxNewLi¡I‹m
->
pxP»vious
 = 
pxIndex
->pxPrevious;

123 
pxIndex
->
pxP»vious
->
pxNext
 = 
pxNewLi¡I‹m
;

124 
pxIndex
->
pxP»vious
 = 
pxNewLi¡I‹m
;

127 
pxNewLi¡I‹m
->
pvCÚš”
 = ( * ) 
pxLi¡
;

129 Ğ
pxLi¡
->
uxNumb”OfI‹ms
 )++;

130 
	}
}

132 
UBa£Ty³_t
 
	$uxLi¡Remove
Ğ
Li¡I‹m_t
 * cÚ¡ 
pxI‹mToRemove
 )

136 
Li¡_t
 * cÚ¡ 
pxLi¡
 = ( Li¡_ˆ* ) 
pxI‹mToRemove
->
pvCÚš”
;

138 
pxI‹mToRemove
->
pxNext
->
pxP»vious
 =…xItemToRemove->pxPrevious;

139 
pxI‹mToRemove
->
pxP»vious
->
pxNext
 =…xItemToRemove->pxNext;

143 ifĞ
pxLi¡
->
pxIndex
 =ğ
pxI‹mToRemove
 )

145 
pxLi¡
->
pxIndex
 = 
pxI‹mToRemove
->
pxP»vious
;

148 
pxI‹mToRemove
->
pvCÚš”
 = 
NULL
;

149 Ğ
pxLi¡
->
uxNumb”OfI‹ms
 )--;

151  
pxLi¡
->
uxNumb”OfI‹ms
;

152 
	}
}

	@list2.h

1 
	~"commÚ.h
"

2 #iâdeà
LIST


3 
	#LIST


	)

4 
	sxLIST_ITEM


7 
TickTy³_t
 
	mxI‹mV®ue
;

8 
xLIST_ITEM
 * 
	mpxNext
;

9 
xLIST_ITEM
 * 
	mpxP»vious
;

10 * 
	mpvOwÃr
;

11 * 
	mpvCÚš”
;

14 
xLIST_ITEM
 
	tLi¡I‹m_t
;

16 
	sxMINI_LIST_ITEM


19 
TickTy³_t
 
	mxI‹mV®ue
;

20 
xLIST_ITEM
 * 
	mpxNext
;

21 
xLIST_ITEM
 * 
	mpxP»vious
;

23 
xMINI_LIST_ITEM
 
	tMšiLi¡I‹m_t
;

28 
	sxLIST


31 
UBa£Ty³_t
 
	muxNumb”OfI‹ms
;

32 
Li¡I‹m_t
 * 
	mpxIndex
;

33 
MšiLi¡I‹m_t
 
	mxLi¡End
;

35 } 
	tLi¡_t
;

36 
	#li¡SET_LIST_ITEM_OWNER
Ğ
pxLi¡I‹m
, 
pxOwÃr
 ) ( (…xLi¡I‹m )->
pvOwÃr
 = ( * ) (…xOwÃ¸è)

	)

37 
	#li¡LIST_IS_EMPTY
Ğ
pxLi¡
 ) ( ( 
Ba£Ty³_t
 ) ( (…xLi¡ )->
uxNumb”OfI‹ms
 =ğĞ
UBa£Ty³_t
 ) 0 ) )

	)

38 
	#li¡GET_OWNER_OF_HEAD_ENTRY
Ğ
pxLi¡
 ) ( (&ĞĞpxLi¡ )->
xLi¡End
 ))->
pxNext
->
pvOwÃr
 )

	)

39 
	#li¡SET_LIST_ITEM_VALUE
Ğ
pxLi¡I‹m
, 
xV®ue
 ) ( (…xLi¡I‹m )->
xI‹mV®ue
 = ( xV®uè)

	)

40 
	#li¡GET_LIST_ITEM_VALUE
Ğ
pxLi¡I‹m
 ) ( (…xLi¡I‹m )->
xI‹mV®ue
 )

	)

41 
	#li¡CURRENT_LIST_LENGTH
Ğ
pxLi¡
 ) ( (…xLi¡ )->
uxNumb”OfI‹ms
 )

	)

42 
	#li¡GET_ITEM_VALUE_OF_HEAD_ENTRY
Ğ
pxLi¡
 ) ( ( (…xLi¡ )->
xLi¡End
 ).
pxNext
->
xI‹mV®ue
 )

	)

43 
	#li¡LIST_ITEM_CONTAINER
Ğ
pxLi¡I‹m
 ) ( (…xLi¡I‹m )->
pvCÚš”
 )

	)

44 
	#li¡GET_OWNER_OF_NEXT_ENTRY
Ğ
pxTCB
, 
pxLi¡
 ) \

46 
Li¡_t
 * cÚ¡ 
pxCÚ¡Li¡
 = ( 
pxLi¡
 ); \

49 Ğ
pxCÚ¡Li¡
 )->
pxIndex
 = (…xCÚ¡Li¡ )->pxIndex->
pxNext
; \

50 ifĞĞ* ) ( 
pxCÚ¡Li¡
 )->
pxIndex
 =ğĞ* ) &ĞĞpxCÚ¡Li¡ )->
xLi¡End
 ) ) \

52 Ğ
pxCÚ¡Li¡
 )->
pxIndex
 = (…xCÚ¡Li¡ )->pxIndex->
pxNext
; \

54 Ğ
pxTCB
 ) = ( 
pxCÚ¡Li¡
 )->
pxIndex
->
pvOwÃr
; \

55 }

	)

	@main.c

1 
	~"h—p2.h
"

2 
	~"queue2.h
"

3 
	~"commÚ.h
"

4 
	~"sk.h
"

6 
Ba£Ty³_t
 
	gxD©a
 = 0;

7 
Te¡Prog¿m
();

8 
	$vSysÿÎIn™
()

10 
	`S‘RuÂšg
();

11 
	`xTaskC»©e
Ğ
Te¡Prog¿m
, "Te¡Prog¿m", 4096, 
NULL
, 20, NULL );

12 
	}
}

14 
	$Te¡Prog¿m
()

17 
Ba£Ty³_t
 
a
 =1;

18 
QueueHªdË_t
 
‹¡queu‘
;

19 
‹¡queu‘
 = 
	`xQueueC»©e
Ğ
bktQUEUE_LENGTH
, Ğ
Ba£Ty³_t
 ) );

20 
	`xQueueS’d
(
‹¡queu‘
,&
a
,0);

21 ifĞ
	`xQueueReûive
Ğ
‹¡queu‘
, &
xD©a
, 0 ) !ğ
”rQUEUE_EMPTY
 )

25 
	}
}

	@other.h

1 
	~"sk.h
"

2 
	#skCHECK_FOR_STACK_OVERFLOW
() \

4 cÚ¡ 
ušt32_t
 * cÚ¡ 
pulSck
 = ( ušt32_ˆ* ) 
pxCu¼’tTCB
->
pxSck
; \

5 cÚ¡ 
ušt32_t
 
ulCheckV®ue
 = ( uint32_t ) 0xa5a5a5a5; \

7 ifĞĞ
pulSck
[ 0 ] !ğ
ulCheckV®ue
 ) || \

	)

8 Ğ
	gpulSck
[ 1 ] !ğ
ulCheckV®ue
 ) || \

9 Ğ
pulSck
[ 2 ] !ğ
ulCheckV®ue
 ) || \

10 Ğ
pulSck
[ 3 ] !ğ
ulCheckV®ue
 ) ) \

12 
vAµliÿtiÚSckOv”æowHook
ĞĞ
TaskHªdË_t
 ) 
pxCu¼’tTCB
,…xCu¼’tTCB->
pcTaskName
 ); \

15 
	$vAµliÿtiÚSckOv”æowHook
Ğ
TaskHªdË_t
 
pxTask
, *
pcTaskName
 )

17 Ğè
pcTaskName
;

18 Ğè
pxTask
;

25 
	}
}

	@queue2.c

2 
	~"commÚ.h
"

3 
	~"li¡2.h
"

4 
	~"queue2.h
"

5 
	~"sk.h
"

6 
	~"time.h
"

7 
	#queueYIELD_IF_USING_PREEMPTION
(è
	`pÜtYIELD_WITHIN_API
()

	)

8 
	#queueUNLOCKED
 ( ( 
Ba£Ty³_t
 ) -1 )

	)

9 
	#queueLOCKED_UNMODIFIED
 ( ( 
Ba£Ty³_t
 ) 0 )

	)

12 
Ba£Ty³_t
 
xQueueG’”icS’dFromISR
Ğ
QueueHªdË_t
 
xQueue
, cÚ¡ * cÚ¡ 
pvI‹mToQueue
, Ba£Ty³_ˆ* cÚ¡ 
pxHigh”PriÜ™yTaskWok’
, cÚ¡ Ba£Ty³_ˆ
xCİyPos™iÚ
 );

14 
vTaskSu¥’dAÎ
( );

15 
Ba£Ty³_t
 
´vIsQueueFuÎ
ĞcÚ¡ 
Queue_t
 *
pxQueue
 );

17 
Ba£Ty³_t
 
	$´vIsQueueEm±y
ĞcÚ¡ 
Queue_t
 *
pxQueue
 )

19 
Ba£Ty³_t
 
xR‘uº
;

21 
	`skENTER_CRITICAL
();

23 ifĞ
pxQueue
->
uxMes§gesWa™šg
 =ğĞ
UBa£Ty³_t
 ) 0 )

25 
xR‘uº
 = 
pdTRUE
;

29 
xR‘uº
 = 
pdFALSE
;

32 
	`skEXIT_CRITICAL
();

34  
xR‘uº
;

35 
	}
}

37 
Ba£Ty³_t
 
	$xQueueG’”icRe£t
Ğ
QueueHªdË_t
 
xQueue
, 
Ba£Ty³_t
 
xNewQueue
 )

39 
Queue_t
 * cÚ¡ 
pxQueue
 = ( Queue_ˆ* ) 
xQueue
;

44 
pxQueue
->
pcTa
 =…xQueue->
pcH—d
 + (…xQueue->
uxL’gth
 *…xQueue->
uxI‹mSize
 );

45 
pxQueue
->
uxMes§gesWa™šg
 = ( 
UBa£Ty³_t
 ) 0U;

46 
pxQueue
->
pcWr™eTo
 =…xQueue->
pcH—d
;

47 
pxQueue
->
u
.
pcR—dFrom
 =…xQueue->
pcH—d
 + ( (…xQueue->
uxL’gth
 - ( 
UBa£Ty³_t
 ) 1U ) *…xQueue->
uxI‹mSize
 );

48 
pxQueue
->
xRxLock
 = 
queueUNLOCKED
;

49 
pxQueue
->
xTxLock
 = 
queueUNLOCKED
;

51 ifĞ
xNewQueue
 =ğ
çl£
 )

58 ifĞ
	`li¡LIST_IS_EMPTY
Ğ&Ğ
pxQueue
->
xTasksWa™šgToS’d
 ) ) =ğ
pdFALSE
 )

60 ifĞ
	`xTaskRemoveFromEv’tLi¡
Ğ&Ğ
pxQueue
->
xTasksWa™šgToS’d
 ) ) =ğ
pdTRUE
 )

62 
	`queueYIELD_IF_USING_PREEMPTION
();

70 
	`vLi¡In™Ÿli£
Ğ&Ğ
pxQueue
->
xTasksWa™šgToS’d
 ) );

71 
	`vLi¡In™Ÿli£
Ğ&Ğ
pxQueue
->
xTasksWa™šgToReûive
 ) );

78  
pdPASS
;

79 
	}
}

89 
QueueHªdË_t
 
	$xQueueG’”icC»©e
ĞcÚ¡ 
UBa£Ty³_t
 
uxQueueL’gth
, cÚ¡ UBa£Ty³_ˆ
uxI‹mSize
, cÚ¡ 
ušt8_t
 
ucQueueTy³
 )

91 
Queue_t
 *
pxNewQueue
;

92 
size_t
 
xQueueSizeInBy‹s
;

93 
QueueHªdË_t
 
xR‘uº
 = 
NULL
;

97 Ğè
ucQueueTy³
;

101 ifĞ
uxI‹mSize
 =ğĞ
UBa£Ty³_t
 ) 0 )

104 
xQueueSizeInBy‹s
 = ( 
size_t
 ) 0;

110 
xQueueSizeInBy‹s
 = ( 
size_t
 ) ( 
uxQueueL’gth
 * 
uxI‹mSize
 ) + ( size_t ) 1;

113 
pxNewQueue
 = ( 
Queue_t
 * ) 
	`pvPÜtM®loc
ĞĞQueue_ˆè+ 
xQueueSizeInBy‹s
 );

116 ifĞ
pxNewQueue
 !ğ
NULL
 )

118 ifĞ
uxI‹mSize
 =ğĞ
UBa£Ty³_t
 ) 0 )

124 
pxNewQueue
->
pcH—d
 = ( 
št8_t
 * )…xNewQueue;

130 
pxNewQueue
->
pcH—d
 = ( ( 
št8_t
 * )…xNewQueuè+ Ğ
Queue_t
 );

135 
pxNewQueue
->
uxL’gth
 = 
uxQueueL’gth
;

136 
pxNewQueue
->
uxI‹mSize
 = uxItemSize;

137 Ğè
	`xQueueG’”icRe£t
Ğ
pxNewQueue
, 
Œue
);

139 #iàĞ
cÚfigUSE_TRACE_FACILITY
 == 1 )

141 
pxNewQueue
->
ucQueueTy³
 = ucQueueType;

145 #ifĞ
cÚfigUSE_QUEUE_SETS
 == 1 )

147 
pxNewQueue
->
pxQueueS‘CÚš”
 = 
NULL
;

152 
xR‘uº
 = 
pxNewQueue
;

155  
xR‘uº
;

156 
	}
}

157 
	$vQueueAddToRegi¡ry
Ğ
QueueHªdË_t
 
xQueue
, cÚ¡ *
pcQueueName
 )

159 
UBa£Ty³_t
 
ux
;

163  
ux
 = ( 
UBa£Ty³_t
 ) 0U; ux < ( UBa£Ty³_ˆè
cÚfigQUEUE_REGISTRY_SIZE
; ux++ )

165 ifĞ
xQueueRegi¡ry
[ 
ux
 ].
pcQueueName
 =ğ
NULL
 )

168 
xQueueRegi¡ry
[ 
ux
 ].
pcQueueName
 =…cQueueName;

169 
xQueueRegi¡ry
[ 
ux
 ].
xHªdË
 = 
xQueue
;

179 
	}
}

181 
Ba£Ty³_t
 
	$´vCİyD©aToQueue
Ğ
Queue_t
 * cÚ¡ 
pxQueue
, cÚ¡ *
pvI‹mToQueue
, cÚ¡ 
Ba£Ty³_t
 
xPos™iÚ
 )

183 
Ba£Ty³_t
 
xR‘uº
 = 
pdFALSE
;

185 ifĞ
pxQueue
->
uxI‹mSize
 =ğĞ
UBa£Ty³_t
 ) 0 )

187 #iàĞ
cÚfigUSE_MUTEXES
 == 1 )

189 ifĞ
pxQueue
->
uxQueueTy³
 =ğ
queueQUEUE_IS_MUTEX
 )

192 
xR‘uº
 = 
	`xTaskPriÜ™yDisšh”™
ĞĞ* ) 
pxQueue
->
pxMu‹xHŞd”
 );

193 
pxQueue
->
pxMu‹xHŞd”
 = 
NULL
;

202 ifĞ
xPos™iÚ
 =ğ
queueSEND_TO_BACK
 )

204 Ğè
	`memıy
ĞĞ* ) 
pxQueue
->
pcWr™eTo
, 
pvI‹mToQueue
, ( 
size_t
 )…xQueue->
uxI‹mSize
 );

205 
pxQueue
->
pcWr™eTo
 +ğpxQueue->
uxI‹mSize
;

206 ifĞ
pxQueue
->
pcWr™eTo
 >ğpxQueue->
pcTa
 )

208 
pxQueue
->
pcWr™eTo
 =…xQueue->
pcH—d
;

217 Ğè
	`memıy
ĞĞ* ) 
pxQueue
->
u
.
pcR—dFrom
, 
pvI‹mToQueue
, ( 
size_t
 )…xQueue->
uxI‹mSize
 );

218 
pxQueue
->
u
.
pcR—dFrom
 -ğpxQueue->
uxI‹mSize
;

219 ifĞ
pxQueue
->
u
.
pcR—dFrom
 <…xQueue->
pcH—d
 )

221 
pxQueue
->
u
.
pcR—dFrom
 = (…xQueue->
pcTa
 -…xQueue->
uxI‹mSize
 );

228 ifĞ
xPos™iÚ
 =ğ
queueOVERWRITE
 )

230 ifĞ
pxQueue
->
uxMes§gesWa™šg
 > ( 
UBa£Ty³_t
 ) 0 )

236 --Ğ
pxQueue
->
uxMes§gesWa™šg
 );

249 ++Ğ
pxQueue
->
uxMes§gesWa™šg
 );

251  
xR‘uº
;

252 
	}
}

266 
Ba£Ty³_t
 
	$xQueueG’”icS’d
Ğ
QueueHªdË_t
 
xQueue
, cÚ¡ * cÚ¡ 
pvI‹mToQueue
, 
TickTy³_t
 
xTicksToWa™
, cÚ¡ 
Ba£Ty³_t
 
xCİyPos™iÚ
 )

268 
Ba£Ty³_t
 
xEÁryTimeS‘
 = 
çl£
, 
xY›ldRequœed
;

269 
TimeOut_t
 
xTimeOut
;

270 
Queue_t
 * cÚ¡ 
pxQueue
 = ( Queue_ˆ* ) 
xQueue
;

293 ifĞĞ
pxQueue
->
uxMes§gesWa™šg
 <…xQueue->
uxL’gth
 ) || ( 
xCİyPos™iÚ
 =ğ
queueOVERWRITE
 ) )

296 
xY›ldRequœed
 = 
	`´vCİyD©aToQueue
Ğ
pxQueue
, 
pvI‹mToQueue
, 
xCİyPos™iÚ
 );

298 #iàĞ
cÚfigUSE_QUEUE_SETS
 == 1 )

300 ifĞ
pxQueue
->
pxQueueS‘CÚš”
 !ğ
NULL
 )

302 ifĞ
	`´vNÙifyQueueS‘CÚš”
Ğ
pxQueue
, 
xCİyPos™iÚ
 ) =ğ
pdTRUE
 )

307 
	`queueYIELD_IF_USING_PREEMPTION
();

318 ifĞ
	`li¡LIST_IS_EMPTY
Ğ&Ğ
pxQueue
->
xTasksWa™šgToReûive
 ) ) =ğ
pdFALSE
 )

320 ifĞ
	`xTaskRemoveFromEv’tLi¡
Ğ&Ğ
pxQueue
->
xTasksWa™šgToReûive
 ) ) =ğ
pdTRUE
 )

326 
	`queueYIELD_IF_USING_PREEMPTION
();

333 ifĞ
xY›ldRequœed
 !ğ
pdFALSE
 )

339 
	`queueYIELD_IF_USING_PREEMPTION
();

351 ifĞ
	`li¡LIST_IS_EMPTY
Ğ&Ğ
pxQueue
->
xTasksWa™šgToReûive
 ) ) =ğ
pdFALSE
 )

353 ifĞ
	`xTaskRemoveFromEv’tLi¡
Ğ&Ğ
pxQueue
->
xTasksWa™šgToReûive
 ) ) =ğ
pdTRUE
 )

359 
	`queueYIELD_IF_USING_PREEMPTION
();

366 ifĞ
xY›ldRequœed
 !ğ
pdFALSE
 )

372 
	`queueYIELD_IF_USING_PREEMPTION
();

381 
	`skEXIT_CRITICAL
();

382  
pdPASS
;

386 ifĞ
xTicksToWa™
 =ğĞ
TickTy³_t
 ) 0 )

390 
	`skEXIT_CRITICAL
();

395  
”rQUEUE_FULL
;

397 ifĞ
xEÁryTimeS‘
 =ğ
pdFALSE
 )

402 
xEÁryTimeS‘
 = 
pdTRUE
;

411 
	`skEXIT_CRITICAL
();

416 
	`vTaskSu¥’dAÎ
();

420 ifĞ
	`xTaskCheckFÜTimeOut
Ğ&
xTimeOut
, &
xTicksToWa™
 ) =ğ
pdFALSE
 )

422 ifĞ
	`´vIsQueueFuÎ
Ğ
pxQueue
 ) !ğ
pdFALSE
 )

425 
	`vTaskPÏûOnEv’tLi¡
Ğ&Ğ
pxQueue
->
xTasksWa™šgToS’d
 ), 
xTicksToWa™
 );

439 ifĞ
	`xTaskResumeAÎ
(è=ğ
pdFALSE
 )

441 
	`pÜtYIELD_WITHIN_API
();

448 Ğè
	`xTaskResumeAÎ
();

455 Ğè
	`xTaskResumeAÎ
();

460  
”rQUEUE_FULL
;

463 
	}
}

468 
	$´vCİyD©aFromQueue
Ğ
Queue_t
 * cÚ¡ 
pxQueue
, * cÚ¡ 
pvBufãr
 )

470 ifĞ
pxQueue
->
uxI‹mSize
 !ğĞ
UBa£Ty³_t
 ) 0 )

472 
pxQueue
->
u
.
pcR—dFrom
 +ğpxQueue->
uxI‹mSize
;

473 ifĞ
pxQueue
->
u
.
pcR—dFrom
 >ğpxQueue->
pcTa
 )

475 
pxQueue
->
u
.
pcR—dFrom
 =…xQueue->
pcH—d
;

481 Ğè
	`memıy
ĞĞ* ) 
pvBufãr
, ( * ) 
pxQueue
->
u
.
pcR—dFrom
, ( 
size_t
 )…xQueue->
uxI‹mSize
 );

483 
	}
}

493 
Ba£Ty³_t
 
	$xQueueG’”icReûive
Ğ
QueueHªdË_t
 
xQueue
, * cÚ¡ 
pvBufãr
, 
TickTy³_t
 
xTicksToWa™
, cÚ¡ 
Ba£Ty³_t
 
xJu¡P“kšg
 )

495 
Ba£Ty³_t
 
xEÁryTimeS‘
 = 
pdFALSE
;

496 
TimeOut_t
 
xTimeOut
;

497 
št8_t
 *
pcOrigš®R—dPos™iÚ
;

498 
Queue_t
 * cÚ¡ 
pxQueue
 = ( Queue_ˆ* ) 
xQueue
;

502 #iàĞĞ
INCLUDE_xTaskG‘ScheduËrS‹
 =ğ1 ) || ( 
cÚfigUSE_TIMERS
 == 1 ) )

514 
	`skENTER_CRITICAL
();

518 ifĞ
pxQueue
->
uxMes§gesWa™šg
 > ( 
UBa£Ty³_t
 ) 0 )

522 
pcOrigš®R—dPos™iÚ
 = 
pxQueue
->
u
.
pcR—dFrom
;

524 
	`´vCİyD©aFromQueue
Ğ
pxQueue
, 
pvBufãr
 );

526 ifĞ
xJu¡P“kšg
 =ğ
pdFALSE
 )

531 --Ğ
pxQueue
->
uxMes§gesWa™šg
 );

533 #iàĞ
cÚfigUSE_MUTEXES
 == 1 )

535 ifĞ
pxQueue
->
uxQueueTy³
 =ğ
queueQUEUE_IS_MUTEX
 )

539 
pxQueue
->
pxMu‹xHŞd”
 = ( 
št8_t
 * ) 
	`pvTaskInüem’tMu‹xH–dCouÁ
();

548 ifĞ
	`li¡LIST_IS_EMPTY
Ğ&Ğ
pxQueue
->
xTasksWa™šgToS’d
 ) ) =ğ
pdFALSE
 )

550 ifĞ
	`xTaskRemoveFromEv’tLi¡
Ğ&Ğ
pxQueue
->
xTasksWa™šgToS’d
 ) ) =ğ
pdTRUE
 )

552 
	`queueYIELD_IF_USING_PREEMPTION
();

570 
pxQueue
->
u
.
pcR—dFrom
 = 
pcOrigš®R—dPos™iÚ
;

574 ifĞ
	`li¡LIST_IS_EMPTY
Ğ&Ğ
pxQueue
->
xTasksWa™šgToReûive
 ) ) =ğ
pdFALSE
 )

576 ifĞ
	`xTaskRemoveFromEv’tLi¡
Ğ&Ğ
pxQueue
->
xTasksWa™šgToReûive
 ) ) !ğ
pdFALSE
 )

579 
	`queueYIELD_IF_USING_PREEMPTION
();

592 
	`skEXIT_CRITICAL
();

593  
pdPASS
;

597 ifĞ
xTicksToWa™
 =ğĞ
TickTy³_t
 ) 0 )

601 
	`skEXIT_CRITICAL
();

603  
”rQUEUE_EMPTY
;

605 ifĞ
xEÁryTimeS‘
 =ğ
pdFALSE
 )

609 
	`vTaskS‘TimeOutS‹
Ğ&
xTimeOut
 );

610 
xEÁryTimeS‘
 = 
pdTRUE
;

619 
	`skEXIT_CRITICAL
();

624 
	`vTaskSu¥’dAÎ
();

628 ifĞ
	`xTaskCheckFÜTimeOut
Ğ&
xTimeOut
, &
xTicksToWa™
 ) =ğ
pdFALSE
 )

630 ifĞ
	`´vIsQueueEm±y
Ğ
pxQueue
 ) !ğ
pdFALSE
 )

634 #iàĞ
cÚfigUSE_MUTEXES
 == 1 )

636 ifĞ
pxQueue
->
uxQueueTy³
 =ğ
queueQUEUE_IS_MUTEX
 )

638 
	`skENTER_CRITICAL
();

640 
	`vTaskPriÜ™yInh”™
ĞĞ* ) 
pxQueue
->
pxMu‹xHŞd”
 );

642 
	`skEXIT_CRITICAL
();

651 
	`vTaskPÏûOnEv’tLi¡
Ğ&Ğ
pxQueue
->
xTasksWa™šgToReûive
 ), 
xTicksToWa™
 );

653 ifĞ
	`xTaskResumeAÎ
(è=ğ
pdFALSE
 )

655 
	`pÜtYIELD_WITHIN_API
();

666 Ğè
	`xTaskResumeAÎ
();

672 Ğè
	`xTaskResumeAÎ
();

674  
”rQUEUE_EMPTY
;

677 
	}
}

679 
Ba£Ty³_t
 
	$´vIsQueueFuÎ
ĞcÚ¡ 
Queue_t
 *
pxQueue
 )

681 
Ba£Ty³_t
 
xR‘uº
;

683 
	`skENTER_CRITICAL
();

685 ifĞ
pxQueue
->
uxMes§gesWa™šg
 =ğpxQueue->
uxL’gth
)

687 
xR‘uº
 = 
pdTRUE
;

691 
xR‘uº
 = 
pdFALSE
;

694 
	`skEXIT_CRITICAL
();

696  
xR‘uº
;

697 
	}
}

701 
Ba£Ty³_t
 
	$xQueueG’”icS’dFromISR
Ğ
QueueHªdË_t
 
xQueue
, cÚ¡ * cÚ¡ 
pvI‹mToQueue
, 
Ba£Ty³_t
 * cÚ¡ 
pxHigh”PriÜ™yTaskWok’
, cÚ¡ Ba£Ty³_ˆ
xCİyPos™iÚ
 )

703 
	}
}

	@queue2.h

2 
	~"li¡2.h
"

3 
	~"commÚ.h
"

4 #iâdeà
QUEUE


5 
	#QUEUE


	)

6 * 
	tQueueHªdË_t
;

8 
	sQUEUE_REGISTRY_ITEM


10 cÚ¡ *
	mpcQueueName
;

11 
QueueHªdË_t
 
	mxHªdË
;

12 } 
	txQueueRegi¡ryI‹m
;

14 
	#queueYIELD_IF_USING_PREEMPTION
(è
	`pÜtYIELD_WITHIN_API
()

	)

16 
	#pÜtYIELD_WITHIN_API
 
pÜtYIELD


	)

17 
	#pÜtYIELD
(è
	`vPÜtY›ld
()

	)

18 
	#xQueueS’dToBackFromISR
Ğ
xQueue
, 
pvI‹mToQueue
, 
pxHigh”PriÜ™yTaskWok’
 ) 
	`xQueueG’”icS’dFromISR
ĞĞxQueu), (…vI‹mToQueu), (…xHigh”PriÜ™yTaskWok’ ), 
queueSEND_TO_BACK
 )

	)

20 
	#skENTER_CRITICAL
(è
	`pÜtENTER_CRITICAL
()

	)

21 
	#skEXIT_CRITICAL
(è
	`pÜtEXIT_CRITICAL
()

	)

23 
	#pÜtENTER_CRITICAL
(è
	`vTaskEÁ”Cr™iÿl
()

	)

26 
	#pÜtEXIT_CRITICAL
(è
	`vTaskEx™Cr™iÿl
()

	)

29 
	#queueQUEUE_TYPE_BASE
 ( ( 
ušt8_t
 ) 0U )

	)

31 
	#xQueueReûive
Ğ
xQueue
, 
pvBufãr
, 
xTicksToWa™
 ) 
	`xQueueG’”icReûive
ĞĞxQueu), (…vBufã¸), ( xTicksToWa™ ), 
pdFALSE
 )

	)

33 
	#xQueueC»©e
Ğ
uxQueueL’gth
, 
uxI‹mSize
 ) 
	`xQueueG’”icC»©e
ĞuxQueueL’gth, uxI‹mSize, 
queueQUEUE_TYPE_BASE
 )

	)

37 
	tBa£Ty³_t
;

39 
	tUBa£Ty³_t
;

41 
	#cÚfigUSE_QUEUE_SETS
 0

	)

43 
	#tskIDLE_PRIORITY
 ( ( 
UBa£Ty³_t
 ) 0U )

	)

45 
	#queueQUEUE_TYPE_BASE
 ( ( 
ušt8_t
 ) 0U )

	)

49 
	#xQueueS’d
Ğ
xQueue
, 
pvI‹mToQueue
, 
xTicksToWa™
 ) 
	`xQueueG’”icS’d
ĞĞxQueu), (…vI‹mToQueu), ( xTicksToWa™ ), 
queueSEND_TO_FRONT
 )

	)

50 
	#xQueueS’dToBack
Ğ
xQueue
, 
pvI‹mToQueue
, 
xTicksToWa™
 ) 
	`xQueueG’”icS’d
ĞĞxQueu), (…vI‹mToQueu), ( xTicksToWa™ ), 
queueSEND_TO_BACK
 )

	)

52 
	#bktQUEUE_LENGTH
 ( 5 )

	)

54 
	#cÚfigQUEUE_REGISTRY_SIZE
 8

	)

55 
xQueueRegi¡ryI‹m
 
	tQueueRegi¡ryI‹m_t
;

64 
	sQueueDefš™iÚ


66 
št8_t
 *
	mpcH—d
;

67 
št8_t
 *
	mpcTa
;

68 
št8_t
 *
	mpcWr™eTo
;

72 
št8_t
 *
	mpcR—dFrom
;

73 
UBa£Ty³_t
 
	muxRecursiveC®lCouÁ
;

74 } 
	mu
;

76 
Li¡_t
 
	mxTasksWa™šgToS’d
;

77 
Li¡_t
 
	mxTasksWa™šgToReûive
;

79 vŞ©
UBa£Ty³_t
 
	muxMes§gesWa™šg
;

80 
UBa£Ty³_t
 
	muxL’gth
;

81 
UBa£Ty³_t
 
	muxI‹mSize
;

83 vŞ©
Ba£Ty³_t
 
	mxRxLock
;

84 vŞ©
Ba£Ty³_t
 
	mxTxLock
;

86 #iàĞ
cÚfigUSE_TRACE_FACILITY
 == 1 )

87 
UBa£Ty³_t
 
	muxQueueNumb”
;

88 
ušt8_t
 
	mucQueueTy³
;

91 #iàĞ
cÚfigUSE_QUEUE_SETS
 == 1 )

92 
QueueDefš™iÚ
 *
	mpxQueueS‘CÚš”
;

95 } 
	txQUEUE
;

96 
xQUEUE
 
	tQueue_t
;

98 
QueueHªdË_t
 
	gxTe¡Queue
;

100 
QueueRegi¡ryI‹m_t
 
	gxQueueRegi¡ry
[ 
cÚfigQUEUE_REGISTRY_SIZE
 ];

	@task.c

1 
	~"sk.h
"

2 
	~"li¡2.h
"

3 
	~"queue2.h
"

4 
	~"commÚ.h
"

5 
	~"Ùh”.h
"

6 
	#pÜtBYTE_ALIGNMENT_MASK
 (0x001f)

	)

7 vŞ©
Ba£Ty³_t
 
	gxScheduËrRuÂšg
 = 
pdFALSE
;

8 vŞ©
UBa£Ty³_t
 
	guxTİR—dyPriÜ™y
 = 
tskIDLE_PRIORITY
;

9 
Li¡_t
 
	gpxR—dyTasksLi¡s
[ 
cÚfigMAX_PRIORITIES
 ];

10 
Li¡_t
 
	gxD–ayedTaskLi¡1
;

11 
Li¡_t
 
	gxD–ayedTaskLi¡2
;

12 
Li¡_t
 * vŞ©
	gpxD–ayedTaskLi¡
;

13 
Li¡_t
 * vŞ©
	gpxOv”æowD–ayedTaskLi¡
;

14 
Li¡_t
 
	gxP’dšgR—dyLi¡
;

15 vŞ©
UBa£Ty³_t
 
	guxCu¼’tNumb”OfTasks
 = ( UBaseType_t ) 0U;

16 vŞ©
TickTy³_t
 
	gxTickCouÁ
 = ( TickType_t ) 0U;

17 
´vIn™Ÿli£TaskLi¡s
( );

20 
Li¡_t
 
	gxSu¥’dedTaskLi¡
;

22 vŞ©
UBa£Ty³_t
 
	guxP’dedTicks
 = ( UBaseType_t ) 0U;

23 vŞ©
Ba£Ty³_t
 
	gxY›ldP’dšg
 = 
pdFALSE
;

24 vŞ©
Ba£Ty³_t
 
	gxNumOfOv”æows
 = ( BaseType_t ) 0;

25 
UBa£Ty³_t
 
	guxTaskNumb”
 = ( UBaseType_t ) 0U;

26 vŞ©
TickTy³_t
 
	gxNextTaskUnblockTime
 = ( TickType_t ) 0U;

27 
TCB_t
 * vŞ©
	gpxCu¼’tTCB
 = 
NULL
;

28 
	#´vAddTaskToR—dyLi¡
Ğ
pxTCB
 ) 
	`vLi¡In£¹End
Ğ&Ğ
pxR—dyTasksLi¡s
[ (…xTCB )->
uxPriÜ™y
 ] ), &ĞĞpxTCB )->
xG’”icLi¡I‹m
 ))

	)

29 
Ba£Ty³_t
 
xTaskInüem’tTick
( );

31 
	#skSWITCH_DELAYED_LISTS
() \

33 
Li¡_t
 *
pxTemp
; \

34 
pxTemp
 = 
pxD–ayedTaskLi¡
; \

35 
pxD–ayedTaskLi¡
 = 
pxOv”æowD–ayedTaskLi¡
; \

36 
pxOv”æowD–ayedTaskLi¡
 = 
pxTemp
; \

37 
xNumOfOv”æows
++; \

38 
	`´vRe£tNextTaskUnblockTime
(); \

39 }

	)

41 
	$´vRe£tNextTaskUnblockTime
( )

43 
TCB_t
 *
pxTCB
;

45 ifĞ
	`li¡LIST_IS_EMPTY
Ğ
pxD–ayedTaskLi¡
 ) !ğ
pdFALSE
 )

51 
xNextTaskUnblockTime
 = 
pÜtMAX_DELAY
;

59 Ğ
pxTCB
 ) = ( 
TCB_t
 * ) 
	`li¡GET_OWNER_OF_HEAD_ENTRY
Ğ
pxD–ayedTaskLi¡
 );

60 
xNextTaskUnblockTime
 = 
	`li¡GET_LIST_ITEM_VALUE
Ğ&ĞĞ
pxTCB
 )->
xG’”icLi¡I‹m
 ) );

62 
	}
}

65 
Ba£Ty³_t
 
	$xTaskResumeAÎ
( )

67 
TCB_t
 *
pxTCB
;

68 
Ba£Ty³_t
 
xAÌ—dyY›lded
 = 
pdFALSE
;

69 
	`skENTER_CRITICAL
();

71 --
uxScheduËrSu¥’ded
;

73 ifĞ
uxScheduËrSu¥’ded
 =ğĞ
UBa£Ty³_t
 ) 
pdFALSE
 )

75 ifĞ
uxCu¼’tNumb”OfTasks
 > ( 
UBa£Ty³_t
 ) 0U )

79  
	`li¡LIST_IS_EMPTY
Ğ&
xP’dšgR—dyLi¡
 ) =ğ
pdFALSE
 )

81 
pxTCB
 = ( 
TCB_t
 * ) 
	`li¡GET_OWNER_OF_HEAD_ENTRY
ĞĞ&
xP’dšgR—dyLi¡
 ) );

82 Ğè
	`uxLi¡Remove
Ğ&Ğ
pxTCB
->
xEv’tLi¡I‹m
 ) );

83 Ğè
	`uxLi¡Remove
Ğ&Ğ
pxTCB
->
xG’”icLi¡I‹m
 ) );

84 
	`´vAddTaskToR—dyLi¡
Ğ
pxTCB
 );

88 ifĞ
pxTCB
->
uxPriÜ™y
 >ğ
pxCu¼’tTCB
->uxPriority )

90 
xY›ldP’dšg
 = 
pdTRUE
;

94 ifĞ
uxP’dedTicks
 > ( 
UBa£Ty³_t
 ) 0U )

96  
uxP’dedTicks
 > ( 
UBa£Ty³_t
 ) 0U )

98 ifĞ
	`xTaskInüem’tTick
(è!ğ
pdFALSE
 )

100 
xY›ldP’dšg
 = 
pdTRUE
;

102 --
uxP’dedTicks
;

105 ifĞ
xY›ldP’dšg
 =ğ
pdTRUE
 )

107 #ifĞ
cÚfigUSE_PREEMPTION
 != 0 )

109 
xAÌ—dyY›lded
 = 
pdTRUE
;

112 
	`skYIELD_IF_USING_PREEMPTION
();

119 
	`skEXIT_CRITICAL
();

121  
xAÌ—dyY›lded
;

123 
	}
}

124 
	$´vTaskEx™E¼Ü
()

127 
	}
}

128 
	$´vIn™Ÿli£TCBV¬ŸbËs
Ğ
TCB_t
 * cÚ¡ 
pxTCB
, cÚ¡ * cÚ¡ 
pcName
, 
UBa£Ty³_t
 
uxPriÜ™y
, cÚ¡ 
MemÜyRegiÚ_t
 * cÚ¡ 
xRegiÚs
, cÚ¡ 
ušt16_t
 
usSckD•th
 )

130 
UBa£Ty³_t
 
x
;

132  
x
 = ( 
UBa£Ty³_t
 ) 0; x < ( UBa£Ty³_ˆè
cÚfigMAX_TASK_NAME_LEN
; x++ )

134 
pxTCB
->
pcTaskName
[ 
x
 ] = 
pcName
[ x ];

136 ifĞ
pcName
[ 
x
 ] == 0x00 )

142 
pxTCB
->
pcTaskName
[ 
cÚfigMAX_TASK_NAME_LEN
 - 1 ] = '\0';

144 ifĞ
uxPriÜ™y
 >ğĞ
UBa£Ty³_t
 ) 
cÚfigMAX_PRIORITIES
 )

146 
uxPriÜ™y
 = ( 
UBa£Ty³_t
 ) 
cÚfigMAX_PRIORITIES
 - ( UBaseType_t ) 1U;

149 
pxTCB
->
uxPriÜ™y
 = uxPriority;

150 #iàĞ
cÚfigUSE_MUTEXES
 == 1 )

152 
pxTCB
->
uxBa£PriÜ™y
 = 
uxPriÜ™y
;

153 
pxTCB
->
uxMu‹xesH–d
 = 0;

157 
	`vLi¡In™Ÿli£I‹m
Ğ&Ğ
pxTCB
->
xG’”icLi¡I‹m
 ) );

158 
	`vLi¡In™Ÿli£I‹m
Ğ&Ğ
pxTCB
->
xEv’tLi¡I‹m
 ) );

160 
	`li¡SET_LIST_ITEM_OWNER
Ğ&Ğ
pxTCB
->
xG’”icLi¡I‹m
 ),…xTCB );

162 
	`li¡SET_LIST_ITEM_VALUE
Ğ&Ğ
pxTCB
->
xEv’tLi¡I‹m
 ), ( 
TickTy³_t
 ) 
cÚfigMAX_PRIORITIES
 - ( TickTy³_ˆè
uxPriÜ™y
 );

163 
	`li¡SET_LIST_ITEM_OWNER
Ğ&Ğ
pxTCB
->
xEv’tLi¡I‹m
 ),…xTCB );

165 #iàĞ
pÜtCRITICAL_NESTING_IN_TCB
 == 1 )

167 
pxTCB
->
uxCr™iÿlNe¡šg
 = ( 
UBa£Ty³_t
 ) 0U;

171 #iàĞ
cÚfigUSE_APPLICATION_TASK_TAG
 == 1 )

173 
pxTCB
->
pxTaskTag
 = 
NULL
;

177 #iàĞ
cÚfigGENERATE_RUN_TIME_STATS
 == 1 )

179 
pxTCB
->
ulRunTimeCouÁ”
 = 0UL;

183 #iàĞ
pÜtUSING_MPU_WRAPPERS
 == 1 )

185 
	`vPÜtStÜeTaskMPUS‘tšgs
Ğ&Ğ
pxTCB
->
xMPUS‘tšgs
 ), 
xRegiÚs
,…xTCB->
pxSck
, 
usSckD•th
 );

189 Ğè
xRegiÚs
;

190 Ğè
usSckD•th
;

194 #ifĞ
cÚfigNUM_THREAD_LOCAL_STORAGE_POINTERS
 != 0 )

196  
x
 = 0; x < ( 
UBa£Ty³_t
 ) 
cÚfigNUM_THREAD_LOCAL_STORAGE_POINTERS
; x++ )

198 
pxTCB
->
pvTh»adLoÿlStÜagePoš‹rs
[ 
x
 ] = 
NULL
;

203 #iàĞ
cÚfigUSE_TASK_NOTIFICATIONS
 == 1 )

205 
pxTCB
->
ulNÙif›dV®ue
 = 0;

206 
pxTCB
->
eNÙifyS‹
 = 
eNÙWa™šgNÙifiÿtiÚ
;

210 #iàĞ
cÚfigUSE_NEWLIB_REENTRANT
 == 1 )

213 
	`_REENT_INIT_PTR
ĞĞ&Ğ
pxTCB
->
xNewLib_»’t
 ) ) );

216 
	}
}

217 
SckTy³_t
 *
	$pxPÜtIn™Ÿli£Sck
Ğ
SckTy³_t
 *
pxTİOfSck
, 
TaskFunùiÚ_t
 
pxCode
, *
pvP¬am‘”s
 )

221 *

 
	`asm
("x3");

222 
pxTİOfSck
--;

223 *
pxTİOfSck
 = (
pÜtSTACK_TYPE
)
pxCode
;

224 
pxTİOfSck
 -= 22;

225 *
pxTİOfSck
 = (
pÜtSTACK_TYPE
)
pvP¬am‘”s
;

226 
pxTİOfSck
 -= 6;

227 *
pxTİOfSck
 = (
pÜtSTACK_TYPE
)

;

228 
pxTİOfSck
 -= 3;

229 *
pxTİOfSck
 = (
pÜtSTACK_TYPE
)
´vTaskEx™E¼Ü
;

231  
pxTİOfSck
;

232 
	}
}

234 
	#skSELECT_HIGHEST_PRIORITY_TASK
() \

236  
	`li¡LIST_IS_EMPTY
Ğ&Ğ
pxR—dyTasksLi¡s
[ 
uxTİR—dyPriÜ™y
 ] ) ) ) \

238 --
uxTİR—dyPriÜ™y
; \

240 
	`li¡GET_OWNER_OF_NEXT_ENTRY
Ğ
pxCu¼’tTCB
, &Ğ
pxR—dyTasksLi¡s
[ 
uxTİR—dyPriÜ™y
 ] ) ); \

241 }

	)

245 
TCB_t
 *
	$´vAÎoÿ‹TCBAndSck
ĞcÚ¡ 
ušt16_t
 
usSckD•th
, 
SckTy³_t
 * cÚ¡ 
puxSckBufãr
 )

247 
TCB_t
 *
pxNewTCB
;

249 #ifĞ
pÜtSTACK_GROWTH
 > 0 )

251 
pxNewTCB
 = ( 
TCB_t
 * ) 
	`pvPÜtM®loc
( ( TCB_t ) );

253 ifĞ
pxNewTCB
 !ğ
NULL
 )

255 
pxNewTCB
->
pxSck
 = ( 
SckTy³_t
 * ) 
	`pvPÜtM®locAligÃd
ĞĞĞĞ
size_t
 ) 
usSckD•th
 ) * ĞSckTy³_ˆè), 
puxSckBufãr
 );

257 ifĞ
pxNewTCB
->
pxSck
 =ğ
NULL
 )

259 
	`vPÜtF»e
Ğ
pxNewTCB
 );

260 
pxNewTCB
 = 
NULL
;

266 
SckTy³_t
 *
pxSck
;

268 
pxSck
 = ( 
SckTy³_t
 * ) 
	`pvPÜtM®locAligÃd
ĞĞĞĞ
size_t
 ) 
usSckD•th
 ) * ĞSckTy³_ˆè), 
puxSckBufãr
 );

270 ifĞ
pxSck
 !ğ
NULL
 )

272 
pxNewTCB
 = ( 
TCB_t
 * ) 
	`pvPÜtM®loc
( ( TCB_t ) );

274 ifĞ
pxNewTCB
 !ğ
NULL
 )

276 
pxNewTCB
->
pxSck
 =…xStack;

280 
	`vPÜtF»e
Ğ
pxSck
 );

285 
pxNewTCB
 = 
NULL
;

290 ifĞ
pxNewTCB
 !ğ
NULL
 )

292 #ifĞĞ
cÚfigCHECK_FOR_STACK_OVERFLOW
 > 1 ) || ( 
cÚfigUSE_TRACE_FACILITY
 =ğ1 ) || ( 
INCLUDE_uxTaskG‘SckHighW©”M¬k
 == 1 ) )

294 Ğè
	`mem£t
Ğ
pxNewTCB
->
pxSck
, ( è
tskSTACK_FILL_BYTE
, ( 
size_t
 ) 
usSckD•th
 * Ğ
SckTy³_t
 ) );

299  
pxNewTCB
;

300 
	}
}

305 
Ba£Ty³_t
 
	$xTaskG’”icC»©e
Ğ
TaskFunùiÚ_t
 
pxTaskCode
, cÚ¡ * cÚ¡ 
pcName
, cÚ¡ 
ušt16_t
 
usSckD•th
,

306 * cÚ¡ 
pvP¬am‘”s
, 
UBa£Ty³_t
 
uxPriÜ™y
, 
TaskHªdË_t
 * cÚ¡ 
pxC»©edTask
, 
SckTy³_t
 * cÚ¡ 
puxSckBufãr
, cÚ¡ 
MemÜyRegiÚ_t
 * cÚ¡ 
xRegiÚs
 )

308 
Ba£Ty³_t
 
xR‘uº
;

309 
TCB_t
 * 
pxNewTCB
;

310 
SckTy³_t
 *
pxTİOfSck
;

314 
pxNewTCB
 = 
	`´vAÎoÿ‹TCBAndSck
Ğ
usSckD•th
, 
puxSckBufãr
 );

315 ifĞ
pxNewTCB
 !ğ
NULL
 )

317 #ifĞ
pÜtUSING_MPU_WRAPPERS
 == 1 )

318 
Ba£Ty³_t
 
xRunPriveged
;

319 ifĞĞ
uxPriÜ™y
 & 
pÜtPRIVILEGE_BIT
 ) != 0U )

321 
xRunPriveged
 = 
pdTRUE
;

325 
xRunPriveged
 = 
pdFALSE
;

327 
uxPriÜ™y
 &ğ~
pÜtPRIVILEGE_BIT
;

329 ifĞ
puxSckBufãr
 !ğ
NULL
 )

331 
pxNewTCB
->
xUsšgStiÿÎyAÎoÿ‹dSck
 = 
pdTRUE
;

335 
pxNewTCB
->
xUsšgStiÿÎyAÎoÿ‹dSck
 = 
pdFALSE
;

339 #ifĞ
pÜtSTACK_GROWTH
 < 0 )

341 
pxTİOfSck
 = 
pxNewTCB
->
pxSck
 + ( 
usSckD•th
 - ( 
ušt16_t
 ) 1 );

342 
pxTİOfSck
 = ( 
SckTy³_t
 * ) ( ( ( 
pÜtPOINTER_SIZE_TYPE
 )…xTİOfSck ) & ( ~ĞĞpÜtPOINTER_SIZE_TYPE ) 
pÜtBYTE_ALIGNMENT_MASK
 ) ) );

347 
pxTİOfSck
 = 
pxNewTCB
->
pxSck
;

349 
pxNewTCB
->
pxEndOfSck
 =…xNewTCB->
pxSck
 + ( 
usSckD•th
 - 1 );

353 
	`´vIn™Ÿli£TCBV¬ŸbËs
Ğ
pxNewTCB
, 
pcName
, 
uxPriÜ™y
, 
xRegiÚs
, 
usSckD•th
 );

355 #ifĞ
pÜtUSING_MPU_WRAPPERS
 == 1 )

357 
pxNewTCB
->
pxTİOfSck
 = 
	`pxPÜtIn™Ÿli£Sck
ĞpxTİOfSck, 
pxTaskCode
, 
pvP¬am‘”s
, 
xRunPriveged
 );

361 
pxNewTCB
->
pxTİOfSck
 = 
	`pxPÜtIn™Ÿli£Sck
ĞpxTİOfSck, 
pxTaskCode
, 
pvP¬am‘”s
 );

365 ifĞĞ* ) 
pxC»©edTask
 !ğ
NULL
 )

367 *
pxC»©edTask
 = ( 
TaskHªdË_t
 ) 
pxNewTCB
;

370 
	`skENTER_CRITICAL
();

372 
uxCu¼’tNumb”OfTasks
++;

373 ifĞ
pxCu¼’tTCB
 =ğ
NULL
 )

375 
pxCu¼’tTCB
 = 
pxNewTCB
;

377 ifĞ
uxCu¼’tNumb”OfTasks
 =ğĞ
UBa£Ty³_t
 ) 1 )

379 
	`´vIn™Ÿli£TaskLi¡s
();

387 ifĞ
xScheduËrRuÂšg
 =ğ
pdFALSE
 )

389 ifĞ
pxCu¼’tTCB
->
uxPriÜ™y
 <= uxPriority )

391 
pxCu¼’tTCB
 = 
pxNewTCB
;

396 
uxTaskNumb”
++;

398 #iàĞ
cÚfigUSE_TRACE_FACILITY
 == 1 )

401 
pxNewTCB
->
uxTCBNumb”
 = 
uxTaskNumb”
;

405 
	`´vAddTaskToR—dyLi¡
(
pxNewTCB
);

407 
xR‘uº
 = 
pdPASS
;

409 
	`skEXIT_CRITICAL
();

413 
xR‘uº
 = 
”rCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
;

416 ifĞ
xR‘uº
 =ğ
pdPASS
 )

418 ifĞ
xScheduËrRuÂšg
 !ğ
pdFALSE
 )

422 ifĞ
pxCu¼’tTCB
->
uxPriÜ™y
 < uxPriority )

424 
	`skYIELD_IF_USING_PREEMPTION
();

429  
xR‘uº
;

430 
	}
}

434 
	$vTaskSw™chCÚ‹xt
( )

436 ifĞ
uxScheduËrSu¥’ded
 !ğĞ
UBa£Ty³_t
 ) 
pdFALSE
 )

438 
xY›ldP’dšg
 = 
pdTRUE
;

442 
xY›ldP’dšg
 = 
pdFALSE
;

444 #iàĞ
cÚfigGENERATE_RUN_TIME_STATS
 == 1 )

446 #ifdeà
pÜtALT_GET_RUN_TIME_COUNTER_VALUE


447 
	`pÜtALT_GET_RUN_TIME_COUNTER_VALUE
Ğ
ulTÙ®RunTime
 );

449 
ulTÙ®RunTime
 = 
	`pÜtGET_RUN_TIME_COUNTER_VALUE
();

452 ifĞ
ulTÙ®RunTime
 > 
ulTaskSw™chedInTime
 )

454 
pxCu¼’tTCB
->
ulRunTimeCouÁ”
 +ğĞ
ulTÙ®RunTime
 - 
ulTaskSw™chedInTime
 );

456 
ulTaskSw™chedInTime
 = 
ulTÙ®RunTime
;

461 
	`skCHECK_FOR_STACK_OVERFLOW
();

465 
	`skSELECT_HIGHEST_PRIORITY_TASK
();

468 #iàĞ
cÚfigUSE_NEWLIB_REENTRANT
 == 1 )

472 
_impu»_±r
 = &Ğ
pxCu¼’tTCB
->
xNewLib_»’t
 );

476 
	}
}

478 
Ba£Ty³_t
 
	$xTaskRemoveFromEv’tLi¡
ĞcÚ¡ 
Li¡_t
 * cÚ¡ 
pxEv’tLi¡
 )

480 
TCB_t
 *
pxUnblockedTCB
;

481 
Ba£Ty³_t
 
xR‘uº
;

482 
pxUnblockedTCB
 = ( 
TCB_t
 * ) 
	`li¡GET_OWNER_OF_HEAD_ENTRY
Ğ
pxEv’tLi¡
 );

483 Ğè
	`uxLi¡Remove
Ğ&Ğ
pxUnblockedTCB
->
xEv’tLi¡I‹m
 ) );

485 ifĞ
uxScheduËrSu¥’ded
 =ğĞ
UBa£Ty³_t
 ) 
pdFALSE
 )

487 Ğè
	`uxLi¡Remove
Ğ&Ğ
pxUnblockedTCB
->
xG’”icLi¡I‹m
 ) );

488 
	`´vAddTaskToR—dyLi¡
Ğ
pxUnblockedTCB
 );

495 
	`vLi¡In£¹End
Ğ&Ğ
xP’dšgR—dyLi¡
 ), &Ğ
pxUnblockedTCB
->
xEv’tLi¡I‹m
 ) );

497 ifĞ
pxUnblockedTCB
->
uxPriÜ™y
 > 
pxCu¼’tTCB
->uxPriority )

502 
xR‘uº
 = 
pdTRUE
;

506 
xY›ldP’dšg
 = 
pdTRUE
;

510 
xR‘uº
 = 
pdFALSE
;

512  
xR‘uº
;

513 
	}
}

515 
Ba£Ty³_t
 
	$xTaskG‘ScheduËrS‹
( )

517 
Ba£Ty³_t
 
xR‘uº
;

519 ifĞ
xScheduËrRuÂšg
 =ğ
pdFALSE
 )

521 
xR‘uº
 = 
skSCHEDULER_NOT_STARTED
;

525 ifĞ
uxScheduËrSu¥’ded
 =ğĞ
UBa£Ty³_t
 ) 
pdFALSE
 )

527 
xR‘uº
 = 
skSCHEDULER_RUNNING
;

531 
xR‘uº
 = 
skSCHEDULER_SUSPENDED
;

535  
xR‘uº
;

536 
	}
}

537 
	$vTaskS¹ScheduËr
( )

539 
Ba£Ty³_t
 
xR‘uº
;

540 ifĞ
xR‘uº
 =ğ
pdPASS
 )

542 
xR‘uº
 = 
	`xTim”C»©eTim”Task
();

544 ifĞ
	`xPÜtS¹ScheduËr
(è!ğ
pdFALSE
 )

550 
	}
}

552 
	$vTaskSu¥’dAÎ
( )

554 ++
uxScheduËrSu¥’ded
;

555 
	}
}

556 
	$vTaskEÁ”Cr™iÿl
( )

558 
	`pÜtDISABLE_INTERRUPTS
();

560 ifĞ
xScheduËrRuÂšg
 !ğ
pdFALSE
 )

562 Ğ
pxCu¼’tTCB
->
uxCr™iÿlNe¡šg
 )++;

570 ifĞ
pxCu¼’tTCB
->
uxCr™iÿlNe¡šg
 == 1 )

579 
	}
}

580 
	$vTaskEx™Cr™iÿl
( )

582 ifĞ
xScheduËrRuÂšg
 !ğ
pdFALSE
 )

584 ifĞ
pxCu¼’tTCB
->
uxCr™iÿlNe¡šg
 > 0U )

586 Ğ
pxCu¼’tTCB
->
uxCr™iÿlNe¡šg
 )--;

588 ifĞ
pxCu¼’tTCB
->
uxCr™iÿlNe¡šg
 == 0U )

590 
	`pÜtENABLE_INTERRUPTS
();

595 
	}
}

596 
	$vTaskS‘TimeOutS‹
Ğ
TimeOut_t
 * cÚ¡ 
pxTimeOut
 )

598 
pxTimeOut
->
xOv”æowCouÁ
 = 
xNumOfOv”æows
;

599 
pxTimeOut
->
xTimeOnEÁ”šg
 = 
xTickCouÁ
;

600 
	}
}

602 
Ba£Ty³_t
 
	$xTaskCheckFÜTimeOut
Ğ
TimeOut_t
 * cÚ¡ 
pxTimeOut
, 
TickTy³_t
 * cÚ¡ 
pxTicksToWa™
 )

604 
Ba£Ty³_t
 
xR‘uº
;

605 cÚ¡ 
TickTy³_t
 
xCÚ¡TickCouÁ
 = 
xTickCouÁ
;

606 ifĞ*
pxTicksToWa™
 =ğ
pÜtMAX_DELAY
 )

608 
xR‘uº
 = 
pdFALSE
;

610 ifĞĞ
xNumOfOv”æows
 !ğ
pxTimeOut
->
xOv”æowCouÁ
 ) && ( 
xCÚ¡TickCouÁ
 >ğpxTimeOut->
xTimeOnEÁ”šg
 ) )

612 
xR‘uº
 = 
pdTRUE
;

614 ifĞĞ
xCÚ¡TickCouÁ
 - 
pxTimeOut
->
xTimeOnEÁ”šg
 ) < *
pxTicksToWa™
 )

617 *
pxTicksToWa™
 -ğĞ
xCÚ¡TickCouÁ
 - 
pxTimeOut
->
xTimeOnEÁ”šg
 );

618 
	`vTaskS‘TimeOutS‹
Ğ
pxTimeOut
 );

619 
xR‘uº
 = 
pdFALSE
;

623 
xR‘uº
 = 
pdTRUE
;

625  
xR‘uº
;

626 
	}
}

627 
	$´vAddCu¼’tTaskToD–ayedLi¡
ĞcÚ¡ 
TickTy³_t
 
xTimeToWake
 )

630 
	`li¡SET_LIST_ITEM_VALUE
Ğ&Ğ
pxCu¼’tTCB
->
xG’”icLi¡I‹m
 ), 
xTimeToWake
 );

632 ifĞ
xTimeToWake
 < 
xTickCouÁ
 )

635 
	`vLi¡In£¹
Ğ
pxOv”æowD–ayedTaskLi¡
, &Ğ
pxCu¼’tTCB
->
xG’”icLi¡I‹m
 ) );

640 
	`vLi¡In£¹
Ğ
pxD–ayedTaskLi¡
, &Ğ
pxCu¼’tTCB
->
xG’”icLi¡I‹m
 ) );

645 ifĞ
xTimeToWake
 < 
xNextTaskUnblockTime
 )

647 
xNextTaskUnblockTime
 = 
xTimeToWake
;

650 
	}
}

652 
	$vTaskPÏûOnEv’tLi¡
Ğ
Li¡_t
 * cÚ¡ 
pxEv’tLi¡
, cÚ¡ 
TickTy³_t
 
xTicksToWa™
 )

654 
TickTy³_t
 
xTimeToWake
;

655 
	`vLi¡In£¹
Ğ
pxEv’tLi¡
, &Ğ
pxCu¼’tTCB
->
xEv’tLi¡I‹m
 ) );

656 ifĞ
	`uxLi¡Remove
Ğ&Ğ
pxCu¼’tTCB
->
xG’”icLi¡I‹m
 ) ) =ğĞ
UBa£Ty³_t
 ) 0 )

661 ifĞ
xTicksToWa™
 =ğ
pÜtMAX_DELAY
 )

666 
	`vLi¡In£¹End
Ğ&
xSu¥’dedTaskLi¡
, &Ğ
pxCu¼’tTCB
->
xG’”icLi¡I‹m
 ) );

673 
xTimeToWake
 = 
xTickCouÁ
 + 
xTicksToWa™
;

674 
	`´vAddCu¼’tTaskToD–ayedLi¡
Ğ
xTimeToWake
 );

677 
	}
}

680 
Ba£Ty³_t
 
	$xTaskInüem’tTick
( )

682 
TCB_t
 * 
pxTCB
;

683 
TickTy³_t
 
xI‹mV®ue
;

684 
Ba£Ty³_t
 
xSw™chRequœed
 = 
pdFALSE
;

685 ifĞ
uxScheduËrSu¥’ded
 =ğĞ
UBa£Ty³_t
 ) 
pdFALSE
 )

687 ++
xTickCouÁ
;

690 cÚ¡ 
TickTy³_t
 
xCÚ¡TickCouÁ
 = 
xTickCouÁ
;

692 ifĞ
xCÚ¡TickCouÁ
 =ğĞ
TickTy³_t
 ) 0U )

694 
	`skSWITCH_DELAYED_LISTS
();

696 ifĞ
xCÚ¡TickCouÁ
 >ğ
xNextTaskUnblockTime
 )

700 ifĞ
	`li¡LIST_IS_EMPTY
Ğ
pxD–ayedTaskLi¡
 ) !ğ
pdFALSE
 )

702 
xNextTaskUnblockTime
 = 
pÜtMAX_DELAY
;

708 
pxTCB
 = ( 
TCB_t
 * ) 
	`li¡GET_OWNER_OF_HEAD_ENTRY
Ğ
pxD–ayedTaskLi¡
 );

709 
xI‹mV®ue
 = 
	`li¡GET_LIST_ITEM_VALUE
Ğ&Ğ
pxTCB
->
xG’”icLi¡I‹m
 ) );

711 ifĞ
xCÚ¡TickCouÁ
 < 
xI‹mV®ue
 )

713 
xNextTaskUnblockTime
 = 
xI‹mV®ue
;

716 Ğè
	`uxLi¡Remove
Ğ&Ğ
pxTCB
->
xG’”icLi¡I‹m
 ) );

720 ifĞ
	`li¡LIST_ITEM_CONTAINER
Ğ&Ğ
pxTCB
->
xEv’tLi¡I‹m
 ) ) !ğ
NULL
 )

722 Ğè
	`uxLi¡Remove
Ğ&Ğ
pxTCB
->
xEv’tLi¡I‹m
 ) );

731 
	`´vAddTaskToR—dyLi¡
Ğ
pxTCB
 );

740 ifĞ
pxTCB
->
uxPriÜ™y
 >ğ
pxCu¼’tTCB
->uxPriority )

742 
xSw™chRequœed
 = 
pdTRUE
;

755 ifĞ
	`li¡CURRENT_LIST_LENGTH
Ğ&Ğ
pxR—dyTasksLi¡s
[ 
pxCu¼’tTCB
->
uxPriÜ™y
 ] ) ) > ( 
UBa£Ty³_t
 ) 1 )

757 
xSw™chRequœed
 = 
pdTRUE
;

763 ++
uxP’dedTicks
;

764 ifĞ
xY›ldP’dšg
 !ğ
pdFALSE
 )

766 
xSw™chRequœed
 = 
pdTRUE
;

770  
xSw™chRequœed
;

771 
	}
}

772 
	$´vIn™Ÿli£TaskLi¡s
( )

774 
UBa£Ty³_t
 
uxPriÜ™y
;

776  
uxPriÜ™y
 = ( 
UBa£Ty³_t
 ) 0U; uxPriÜ™y < ( UBa£Ty³_ˆè
cÚfigMAX_PRIORITIES
; uxPriority++ )

778 
	`vLi¡In™Ÿli£
Ğ&Ğ
pxR—dyTasksLi¡s
[ 
uxPriÜ™y
 ] ) );

781 
	`vLi¡In™Ÿli£
Ğ&
xD–ayedTaskLi¡1
 );

782 
	`vLi¡In™Ÿli£
Ğ&
xD–ayedTaskLi¡2
 );

783 
	`vLi¡In™Ÿli£
Ğ&
xP’dšgR—dyLi¡
 );

785 #iàĞ
INCLUDE_vTaskD–‘e
 == 1 )

787 
	`vLi¡In™Ÿli£
Ğ&
xTasksWa™šgT”mš©iÚ
 );

791 #iàĞ
INCLUDE_vTaskSu¥’d
 == 1 )

793 
	`vLi¡In™Ÿli£
Ğ&
xSu¥’dedTaskLi¡
 );

799 
pxD–ayedTaskLi¡
 = &
xD–ayedTaskLi¡1
;

800 
pxOv”æowD–ayedTaskLi¡
 = &
xD–ayedTaskLi¡2
;

801 
	}
}

802 
	$S‘RuÂšg
()

804 
Ba£Ty³_t
 
xScheduËrRuÂšg
 = 
Œue
;

806 
	}
}

	@task.h

1 
	~"commÚ.h
"

2 
	~"li¡2.h
"

3 
	~"queue2.h
"

4 #iâdeà
TASK


5 
	#TASK


	)

6 
	#xTaskC»©e
Ğ
pvTaskCode
, 
pcName
, 
usSckD•th
, 
pvP¬am‘”s
, 
uxPriÜ™y
, 
pxC»©edTask
 ) 
	`xTaskG’”icC»©e
ĞĞpvTaskCod), (…cNam), ( usSckD•th ), (…vP¬am‘” ), ( uxPriÜ™y ), (…xC»©edTask ), ( 
NULL
 ), ( NULL ) )

	)

7 vŞ©
UBa£Ty³_t
 
	guxScheduËrSu¥’ded
 = ( UBa£Ty³_ˆè
pdFALSE
;

8 
vTaskPÏûOnEv’tLi¡
Ğ
Li¡_t
 * cÚ¡ 
pxEv’tLi¡
, cÚ¡ 
TickTy³_t
 
xTicksToWa™
 );

9 * 
	tTaskHªdË_t
;

10 
	sxMEMORY_REGION


12 *
	mpvBa£Add»ss
;

13 
ušt32_t
 
	mulL’gthInBy‹s
;

14 
ušt32_t
 
	mulP¬am‘”s
;

15 } 
	tMemÜyRegiÚ_t
;

17 
	sxTIME_OUT


19 
Ba£Ty³_t
 
	mxOv”æowCouÁ
;

20 
TickTy³_t
 
	mxTimeOnEÁ”šg
;

21 } 
	tTimeOut_t
;

22 
	#skSCHEDULER_SUSPENDED
 ( ( 
Ba£Ty³_t
 ) 0 )

	)

23 
	#skSCHEDULER_NOT_STARTED
 ( ( 
Ba£Ty³_t
 ) 1 )

	)

24 
	#skSCHEDULER_RUNNING
 ( ( 
Ba£Ty³_t
 ) 2 )

	)

26 
	stskTaskCÚŒŞBlock


28 vŞ©
SckTy³_t
 *
	mpxTİOfSck
;

30 #iàĞ
pÜtUSING_MPU_WRAPPERS
 == 1 )

31 
xMPU_SETTINGS
 
	mxMPUS‘tšgs
;

32 
Ba£Ty³_t
 
	mxUsšgStiÿÎyAÎoÿ‹dSck
;

35 
Li¡I‹m_t
 
	mxG’”icLi¡I‹m
;

36 
Li¡I‹m_t
 
	mxEv’tLi¡I‹m
;

37 
UBa£Ty³_t
 
	muxPriÜ™y
;

38 
SckTy³_t
 *
	mpxSck
;

39 
	mpcTaskName
[ 
cÚfigMAX_TASK_NAME_LEN
 ];

41 
SckTy³_t
 *
	mpxEndOfSck
;

44 #iàĞ
pÜtCRITICAL_NESTING_IN_TCB
 == 1 )

45 
UBa£Ty³_t
 
	muxCr™iÿlNe¡šg
;

48 #iàĞ
cÚfigUSE_TRACE_FACILITY
 == 1 )

49 
UBa£Ty³_t
 
	muxTCBNumb”
;

50 
UBa£Ty³_t
 
	muxTaskNumb”
;

53 #iàĞ
cÚfigUSE_MUTEXES
 == 1 )

54 
UBa£Ty³_t
 
	muxBa£PriÜ™y
;

55 
UBa£Ty³_t
 
	muxMu‹xesH–d
;

58 #iàĞ
cÚfigUSE_APPLICATION_TASK_TAG
 == 1 )

59 
TaskHookFunùiÚ_t
 
	mpxTaskTag
;

62 #ifĞ
cÚfigNUM_THREAD_LOCAL_STORAGE_POINTERS
 > 0 )

63 *
	mpvTh»adLoÿlStÜagePoš‹rs
[ 
cÚfigNUM_THREAD_LOCAL_STORAGE_POINTERS
 ];

66 #iàĞ
	tcÚfigGENERATE_RUN_TIME_STATS
 == 1 )

67 
	tušt32_t
 
	tulRunTimeCouÁ”
;

70 #iàĞ
cÚfigUSE_NEWLIB_REENTRANT
 == 1 )

78 
_»’t
 
	gxNewLib_»’t
;

81 #iàĞ
cÚfigUSE_TASK_NOTIFICATIONS
 == 1 )

82 vŞ©
ušt32_t
 
	gulNÙif›dV®ue
;

83 vŞ©
eNÙifyV®ue
 
	geNÙifyS‹
;

86 } 
	gtskTCB
;

87 
S‘RuÂšg
();

92 
tskTCB
 
	tTCB_t
;

93 
	#skYIELD_IF_USING_PREEMPTION
(è
	`pÜtYIELD_WITHIN_API
()

	)

	@time.c

1 
	~"time.h
"

2 
	~"commÚ.h
"

3 
	~"sk.h
"

4 
	~"’codšg.h
"

5 
Li¡_t
 
	gxAùiveTim”Li¡1
;

6 
Li¡_t
 
	gxAùiveTim”Li¡2
;

7 
Li¡_t
 *
	gpxCu¼’tTim”Li¡
;

8 
Li¡_t
 *
	gpxOv”æowTim”Li¡
;

10 
QueueHªdË_t
 
	gxTim”Queue
 = 
NULL
;

12 
	stmrTim”P¬am‘”s


14 
TickTy³_t
 
	mxMes§geV®ue
;

15 
Tim”_t
 * 
	mpxTim”
;

16 } 
	tTim”P¬am‘”_t
;

18 
	stmrTim”QueueMes§ge


20 
Ba£Ty³_t
 
	mxMes§geID
;

23 
Tim”P¬am‘”_t
 
	mxTim”P¬am‘”s
;

27 #iàĞ
INCLUDE_xTim”P’dFunùiÚC®l
 == 1 )

28 
C®lbackP¬am‘”s_t
 
	mxC®lbackP¬am‘”s
;

30 } 
	mu
;

31 } 
	tD«mÚTaskMes§ge_t
;

35 
	$´vS‘NextTim”IÁ”ru±
()

37 
__asm
 vŞ©e("ld0,0(%0)"::"r"
mtimecmp
);

38 
__asm
 vŞ©e("add0,t0,%0" :: "r"(
cÚfigTICK_CLOCK_HZ
 / 
cÚfigTICK_RATE_HZ
));

39 
__asm
 vŞ©e("sd %0,0Ñ0)"::"r"
mtimecmp
);

40 
	}
}

43 
	$vPÜtS‘upTim”
()

45 
__asm
 vŞ©e("ld0,0(%0)"::"r"
mtimecmp
);

46 
__asm
 vŞ©e("add0,t0,%0"::"r"(
cÚfigTICK_CLOCK_HZ
 / 
cÚfigTICK_RATE_HZ
));

47 
__asm
 vŞ©e("sd %0,0Ñ0)"::"r"
mtimecmp
);

50 
__asm
 volatile("csrs mie,%0"::"r"(0x80));

51 
	}
}

53 
	$vPÜtSysTickHªdËr
( )

55 
	`´vS‘NextTim”IÁ”ru±
();

58 ifĞ
	`xTaskInüem’tTick
(è!ğ
pdFALSE
 )

60 
	`vTaskSw™chCÚ‹xt
();

62 
	}
}

63 
	$´vCheckFÜV®idLi¡AndQueue
( )

65 ifĞ
xTim”Queue
 =ğ
NULL
 )

67 
	`vLi¡In™Ÿli£
Ğ&
xAùiveTim”Li¡1
 );

68 
	`vLi¡In™Ÿli£
Ğ&
xAùiveTim”Li¡2
 );

69 
pxCu¼’tTim”Li¡
 = &
xAùiveTim”Li¡1
;

70 
pxOv”æowTim”Li¡
 = &
xAùiveTim”Li¡2
;

71 
xTim”Queue
 = 
	`xQueueC»©e
ĞĞ
UBa£Ty³_t
 ) 
cÚfigTIMER_QUEUE_LENGTH
, Ğ
D«mÚTaskMes§ge_t
 ) );

73 ifĞ
xTim”Queue
 !ğ
NULL
 )

75 
	`vQueueAddToRegi¡ry
Ğ
xTim”Queue
, "TmrQ" );

79 
	}
}

80 
Tim”HªdË_t
 
	$xTim”C»©e
ĞcÚ¡ * cÚ¡ 
pcTim”Name
, cÚ¡ 
TickTy³_t
 
xTim”P”iodInTicks
, cÚ¡ 
UBa£Ty³_t
 
uxAutoR–ßd
, * cÚ¡ 
pvTim”ID
, 
Tim”C®lbackFunùiÚ_t
 
pxC®lbackFunùiÚ
 )

82 
Tim”_t
 *
pxNewTim”
;

83 ifĞ
xTim”P”iodInTicks
 =ğĞ
TickTy³_t
 ) 0U )

85 
pxNewTim”
 = 
NULL
;

89 
pxNewTim”
 = ( 
Tim”_t
 * ) 
	`pvPÜtM®loc
( ( Timer_t ) );

90 ifĞ
pxNewTim”
 !ğ
NULL
 )

94 
	`´vCheckFÜV®idLi¡AndQueue
();

97 
pxNewTim”
->
pcTim”Name
 =…cTimerName;

98 
pxNewTim”
->
xTim”P”iodInTicks
 = xTimerPeriodInTicks;

99 
pxNewTim”
->
uxAutoR–ßd
 = uxAutoReload;

100 
pxNewTim”
->
pvTim”ID
 =…vTimerID;

101 
pxNewTim”
->
pxC®lbackFunùiÚ
 =…xCallbackFunction;

102 
	`vLi¡In™Ÿli£I‹m
Ğ&Ğ
pxNewTim”
->
xTim”Li¡I‹m
 ) );

111  ( 
Tim”HªdË_t
 ) 
pxNewTim”
;

113 
	}
}

115 
TickTy³_t
 
	$´vG‘NextExpœeTime
Ğ
Ba£Ty³_t
 * cÚ¡ 
pxLi¡WasEm±y
 )

117 
TickTy³_t
 
xNextExpœeTime
;

126 *
pxLi¡WasEm±y
 = 
	`li¡LIST_IS_EMPTY
Ğ
pxCu¼’tTim”Li¡
 );

127 ifĞ*
pxLi¡WasEm±y
 =ğ
pdFALSE
 )

129 
xNextExpœeTime
 = 
	`li¡GET_ITEM_VALUE_OF_HEAD_ENTRY
Ğ
pxCu¼’tTim”Li¡
 );

134 
xNextExpœeTime
 = ( 
TickTy³_t
 ) 0U;

137  
xNextExpœeTime
;

138 
	}
}

140 
	$´vTim”Task
Ğ*
pvP¬am‘”s
 )

142 
TickTy³_t
 
xNextExpœeTime
;

143 
Ba£Ty³_t
 
xLi¡WasEm±y
;

157 
	}
}

166 
Ba£Ty³_t
 
	$xTim”G’”icCommªd
Ğ
Tim”HªdË_t
 
xTim”
, cÚ¡ 
Ba£Ty³_t
 
xCommªdID
, cÚ¡ 
TickTy³_t
 
xO±iÚ®V®ue
, Ba£Ty³_ˆ* cÚ¡ 
pxHigh”PriÜ™yTaskWok’
, cÚ¡ TickTy³_ˆ
xTicksToWa™
 )

168 
Ba£Ty³_t
 
xR‘uº
 = 
pdFAIL
;

169 
D«mÚTaskMes§ge_t
 
xMes§ge
;

170 ifĞ
xTim”Queue
 !ğ
NULL
 )

173 
xMes§ge
.
xMes§geID
 = 
xCommªdID
;

174 
xMes§ge
.
u
.
xTim”P¬am‘”s
.
xMes§geV®ue
 = 
xO±iÚ®V®ue
;

175 
xMes§ge
.
u
.
xTim”P¬am‘”s
.
pxTim”
 = ( 
Tim”_t
 * ) 
xTim”
;

177 ifĞ
xCommªdID
 < 
tmrFIRST_FROM_ISR_COMMAND
 )

179 ifĞ
	`xTaskG‘ScheduËrS‹
(è=ğ
skSCHEDULER_RUNNING
 )

181 
xR‘uº
 = 
	`xQueueS’dToBack
Ğ
xTim”Queue
, &
xMes§ge
, 
xTicksToWa™
 );

185 
xR‘uº
 = 
	`xQueueS’dToBack
Ğ
xTim”Queue
, &
xMes§ge
, 0 );

190 
xR‘uº
 = 
	`xQueueS’dToBackFromISR
Ğ
xTim”Queue
, &
xMes§ge
, 
pxHigh”PriÜ™yTaskWok’
 );

193  
xR‘uº
;

194 
	}
}

195 
Ba£Ty³_t
 
	$xTim”C»©eTim”Task
( )

198 
Ba£Ty³_t
 
xR‘uº
 = 
pdFAIL
;

199 
	`´vCheckFÜV®idLi¡AndQueue
();

200 ifĞ
xTim”Queue
 !ğ
NULL
 )

202 
xR‘uº
 = 
	`xTaskC»©e
Ğ
´vTim”Task
, "Tm¸Svc", ( 
ušt16_t
 ) 
cÚfigTIMER_TASK_STACK_DEPTH
, 
NULL
, ( ( 
UBa£Ty³_t
 ) 
cÚfigTIMER_TASK_PRIORITY
 ) | 
pÜtPRIVILEGE_BIT
, NULL);

204  
xR‘uº
;

205 
	}
}

	@time.h

1 
	~"commÚ.h
"

2 
	~"li¡2.h
"

3 
	#CSR_MIE
 (0x304)

	)

4 
	#CSR_MTVEC
 (0x305)

	)

5 
	#mtimecmp
 (0x2004000)

	)

6 
	#mtime
 (0x200bff8)

	)

8 
	#cÚfigTICK_CLOCK_HZ
 ( ( è1000000 )

	)

9 
	#cÚfigTICK_RATE_HZ
 ( ( 
TickTy³_t
 ) 1000 )

	)

11 
	#tmrCOMMAND_EXECUTE_CALLBACK_FROM_ISR
 ( ( 
Ba£Ty³_t
 ) -2 )

	)

12 
	#tmrCOMMAND_EXECUTE_CALLBACK
 ( ( 
Ba£Ty³_t
 ) -1 )

	)

13 
	#tmrCOMMAND_START_DONT_TRACE
 ( ( 
Ba£Ty³_t
 ) 0 )

	)

14 
	#tmrCOMMAND_START
 ( ( 
Ba£Ty³_t
 ) 1 )

	)

15 
	#tmrCOMMAND_RESET
 ( ( 
Ba£Ty³_t
 ) 2 )

	)

16 
	#tmrCOMMAND_STOP
 ( ( 
Ba£Ty³_t
 ) 3 )

	)

17 
	#tmrCOMMAND_CHANGE_PERIOD
 ( ( 
Ba£Ty³_t
 ) 4 )

	)

18 
	#tmrCOMMAND_DELETE
 ( ( 
Ba£Ty³_t
 ) 5 )

	)

20 
	#tmrFIRST_FROM_ISR_COMMAND
 ( ( 
Ba£Ty³_t
 ) 6 )

	)

21 
	#tmrCOMMAND_START_FROM_ISR
 ( ( 
Ba£Ty³_t
 ) 6 )

	)

22 
	#tmrCOMMAND_RESET_FROM_ISR
 ( ( 
Ba£Ty³_t
 ) 7 )

	)

23 
	#tmrCOMMAND_STOP_FROM_ISR
 ( ( 
Ba£Ty³_t
 ) 8 )

	)

24 
	#tmrCOMMAND_CHANGE_PERIOD_FROM_ISR
 ( ( 
Ba£Ty³_t
 ) 9 )

	)

26 * 
	tTim”HªdË_t
;

27 (*
	tTim”C®lbackFunùiÚ_t
)Ğ
	tTim”HªdË_t
 
	txTim”
 );

28 
	stmrTim”CÚŒŞ


30 cÚ¡ *
pcTim”Name
;

31 
Li¡I‹m_t
 
xTim”Li¡I‹m
;

32 
TickTy³_t
 
xTim”P”iodInTicks
;

33 
UBa£Ty³_t
 
uxAutoR–ßd
;

34 *
pvTim”ID
;

35 
Tim”C®lbackFunùiÚ_t
 
pxC®lbackFunùiÚ
;

36 #ifĞ
cÚfigUSE_TRACE_FACILITY
 == 1 )

37 
UBa£Ty³_t
 
uxTim”Numb”
;

39 } 
	txTIMER
;

40 
xTIMER
 
	tTim”_t
;

42 
	#xTim”S¹
Ğ
xTim”
, 
xTicksToWa™
 ) 
	`xTim”G’”icCommªd
ĞĞxTim” ), 
tmrCOMMAND_START
, ( 
	`xTaskG‘TickCouÁ
(è), 
NULL
, ( xTicksToWa™ ) )

	)

	@
1
.
1
/usr/include
15
122
common.c
common.h
encoding.h
heap2.c
heap2.h
list2.c
list2.h
main.c
other.h
queue2.c
queue2.h
task.c
task.h
time.c
time.h
